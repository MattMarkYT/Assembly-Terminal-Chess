Microsoft (R) Macro Assembler Version 14.44.35217.0	    10/18/25 13:24:52
TerminalChess.asm					     Page 1 - 1


				; Author: Matthew Marquez
				; Terminal Chess written in assembly

				include Irvine32.inc
			      C ; Include file for Irvine32.lib             (Irvine32.inc)
			      C 
			      C ;OPTION CASEMAP:NONE		; optional: make identifiers case-sensitive
			      C 
			      C INCLUDE SmallWin.inc		; MS-Windows prototypes, structures, and constants
			      C .NOLIST
			      C .LIST
			      C 
			      C INCLUDE VirtualKeys.inc
			      C ; VirtualKeys.inc
			      C .NOLIST
			      C .LIST
			      C 
			      C 
			      C .NOLIST
			      C .LIST
			      C 
				include Macros.inc
			      C .NOLIST
			      C .LIST
			      C 

				include SmallHelpers.inc
			      C COMMENT !
			      C 
			      C List of Procedures:
			      C 
			      C YesOrNo PROTO
			      C 	-- Takes character in al and checks if it's y or n
			      C 	-- sets carry flag if al is 'y' or 'Y'
			      C 	-- sets zero flag if al is 'n' or 'N'
			      C 	-- Usage: After calling, check carry flag before zero flag
			      C 
			      C NormalizeVectors PROTO
			      C 	-- Takes in al(x) and ah(y) and normalizes them
			      C 	-- Turns to 1 if positive, -1 if negative, 0 if zero
			      C 
			      C GetCoordsDifference PROTO
			      C 	-- takes the coords in edx and returns the difference
			      C 	-- al is difference in x, cl is the absolute value
			      C 	-- ah is difference in y, ch is the absolute value
			      C 
			      C END COMMENT !
			      C 
			      C YesOrNo PROTO
			      C NormalizeVectors PROTO
			      C GetCoordsDifference PROTO
			      C 
				include ChessFeedback.inc
			      C COMMENT !
			      C 
			      C List of Macros:
			      C 
			      C SetFeedback MACRO type:REQ
			      C 	-- Sets the FEEDBACK variable to the given feedback type
			      C 
			      C GetFeedback MACRO
			      C 	-- Sets al to the value of FEEDBACK
			      C 
			      C PrintFeedback MACRO
			      C 	-- Prints the given feedback type in the FEEDBACK variable then clears the variable, else prints nothing
			      C 
			      C END COMMENT !
			      C 
			      C ; Feedback Types
 = 00000001		      C INVALID_MOVE        EQU 1
 = 00000002		      C MOVE_OUTSIDE_RANGE  EQU 2
 = 00000003		      C KING_LEFT_IN_CHECK  EQU 3
 = 00000004		      C EMPTY_SQUARE_MOVE   EQU 4
 = 00000005		      C MISMATCH_COLOR      EQU 5
 = 00000006		      C MISMATCH_COLOR_CAPT EQU 6
 = 00000007		      C BLOCKED_PATH        EQU 7
 = 00000008		      C ERROR_PATH          EQU 8
 = 00000009		      C ERROR_KING_CAPTURE  EQU 9
			      C 
 00000000		      C .data
 00000000 00		      C 	FEEDBACK BYTE 0
			      C 
 00000001 49 6E 76 61 6C      C 	INVALID_MOVE_STR		BYTE "Invalid Move!",13,10,0
	   69 64 20 4D 6F
	   76 65 21 0D 0A
	   00
 00000011 49 6E 76 61 6C      C 	MOVE_OUTSIDE_RANGE_STR	BYTE "Invalid Syntax / Outside Range!",13,10,0
	   69 64 20 53 79
	   6E 74 61 78 20
	   2F 20 4F 75 74
	   73 69 64 65 20
	   52 61 6E 67 65
	   21 0D 0A 00
 00000033 59 6F 75 72 20      C 	KING_LEFT_IN_CHECK_STR	BYTE "Your king is left in check!",13,10,0
	   6B 69 6E 67 20
	   69 73 20 6C 65
	   66 74 20 69 6E
	   20 63 68 65 63
	   6B 21 0D 0A 00
 00000051 53 74 61 72 74      C 	EMPTY_SQUARE_MOVE_STR	BYTE "Starting square is empty!",13,10,0
	   69 6E 67 20 73
	   71 75 61 72 65
	   20 69 73 20 65
	   6D 70 74 79 21
	   0D 0A 00
 0000006D 43 61 6E 27 74      C 	MISMATCH_COLOR_STR		BYTE "Can't move piece that's not yours!",13,10,0
	   20 6D 6F 76 65
	   20 70 69 65 63
	   65 20 74 68 61
	   74 27 73 20 6E
	   6F 74 20 79 6F
	   75 72 73 21 0D
	   0A 00
 00000092 59 6F 75 20 61      C 	MISMATCH_COLOR_CAPT_STR	BYTE "You already occupying the end square!",13,10,0
	   6C 72 65 61 64
	   79 20 6F 63 63
	   75 70 79 69 6E
	   67 20 74 68 65
	   20 65 6E 64 20
	   73 71 75 61 72
	   65 21 0D 0A 00
 000000BA 50 61 74 68 20      C 	BLOCKED_PATH_STR		BYTE "Path between start and end is blocked by a piece!",13,10,0
	   62 65 74 77 65
	   65 6E 20 73 74
	   61 72 74 20 61
	   6E 64 20 65 6E
	   64 20 69 73 20
	   62 6C 6F 63 6B
	   65 64 20 62 79
	   20 61 20 70 69
	   65 63 65 21 0D
	   0A 00
 000000EE 41 20 62 75 67      C 	ERROR_PATH_STR			BYTE "A bug occurred when checking the path between pieces",13,10,0
	   20 6F 63 63 75
	   72 72 65 64 20
	   77 68 65 6E 20
	   63 68 65 63 6B
	   69 6E 67 20 74
	   68 65 20 70 61
	   74 68 20 62 65
	   74 77 65 65 6E
	   20 70 69 65 63
	   65 73 0D 0A 00
 00000125 59 6F 75 20 73      C 	ERROR_KING_CAPTURE_STR	BYTE "You should never be able to capture the king. That's a bug",13,10,0
	   68 6F 75 6C 64
	   20 6E 65 76 65
	   72 20 62 65 20
	   61 62 6C 65 20
	   74 6F 20 63 61
	   70 74 75 72 65
	   20 74 68 65 20
	   6B 69 6E 67 2E
	   20 54 68 61 74
	   27 73 20 61 20
	   62 75 67 0D 0A
	   00
			      C 
			      C SetFeedback MACRO type:REQ
			      C 	mov FEEDBACK, type
			      C ENDM
			      C 
			      C GetFeedback MACRO
			      C 	mov al, FEEDBACK
			      C ENDM
			      C 
			      C PrintFeedback MACRO
			      C 
			      C     ; Set text color to red
			      C     mov eax, red + (black*16)
			      C     call SetTextColor
			      C 
			      C     mov al, FEEDBACK
			      C     cmp al, 0
			      C     je SKIP_PRINT                   ; skip to end if there is no feedback
			      C 
			      C     cmp al, INVALID_MOVE
			      C     je INVALID_MOVE_F
			      C 
			      C     cmp al, MOVE_OUTSIDE_RANGE
			      C     je MOVE_OUTSIDE_RANGE_F
			      C 
			      C     cmp al, MISMATCH_COLOR
			      C     je MISMATCH_COLOR_F
			      C 
			      C     cmp al, MISMATCH_COLOR_CAPT
			      C     je MISMATCH_COLOR_CAPT_F
			      C 
			      C     cmp al, BLOCKED_PATH
			      C     je BLOCKED_PATH_F
			      C 
			      C     cmp al, KING_LEFT_IN_CHECK
			      C     je KING_LEFT_IN_CHECK_F
			      C 
			      C     cmp al, EMPTY_SQUARE_MOVE
			      C     je EMPTY_SQUARE_MOVE_F
			      C 
			      C     cmp al, ERROR_PATH
			      C     je ERROR_PATH_F
			      C 
			      C     cmp al, ERROR_KING_CAPTURE
			      C     je ERROR_KING_CAPTURE_F
			      C     
			      C     jmp SKIP_PRINT                  ; If no feedback was found, skip to the end
			      C 
			      C     ; Set edx to the corresponding feedback string
			      C     INVALID_MOVE_F:
			      C         mov edx, OFFSET INVALID_MOVE_STR
			      C         jmp END_OF_FEEDBACK
			      C 
			      C     MISMATCH_COLOR_F:
			      C         mov edx, OFFSET MISMATCH_COLOR_STR
			      C         jmp END_OF_FEEDBACK
			      C 
			      C     MISMATCH_COLOR_CAPT_F:
			      C         mov edx, OFFSET MISMATCH_COLOR_CAPT_STR
			      C         jmp END_OF_FEEDBACK
			      C 
			      C     MOVE_OUTSIDE_RANGE_F:
			      C         mov edx, OFFSET MOVE_OUTSIDE_RANGE_STR
			      C         jmp END_OF_FEEDBACK
			      C 
			      C     KING_LEFT_IN_CHECK_F:
			      C         mov edx, OFFSET KING_LEFT_IN_CHECK_STR
			      C         jmp END_OF_FEEDBACK
			      C 
			      C     EMPTY_SQUARE_MOVE_F:
			      C         mov edx, OFFSET EMPTY_SQUARE_MOVE_STR
			      C         jmp END_OF_FEEDBACK
			      C 
			      C     BLOCKED_PATH_F:
			      C         mov edx, OFFSET BLOCKED_PATH_STR
			      C         jmp END_OF_FEEDBACK
			      C 
			      C     ERROR_KING_CAPTURE_F:
			      C         mov edx, OFFSET ERROR_KING_CAPTURE_STR
			      C         jmp END_OF_FEEDBACK
			      C 
			      C     ERROR_PATH_F:
			      C         mov edx, OFFSET ERROR_PATH_STR
			      C 
			      C 
			      C     END_OF_FEEDBACK:
			      C     call WriteString                ; Print out feedback in edx
			      C 
			      C     SKIP_PRINT:
			      C     mov eax, white + (black*16)     ; Set text color back to white
			      C     call SetTextColor
			      C     mov FEEDBACK, 0
			      C 
			      C ENDM
			      C 

				; PIECE INFORMATION

				; The pieces on the board are stored as BYTES
				; The 2 left-most bit signifies BLACK/WHITE/EMPTY
				; The next 2 bits signify if the piece has moved once and twice respectively
				; The 4 right-most bits signify the PIECE TYPE

 = 00000005			INPUT_SIZE EQU 5



				; Symbols
 = 0000004B			SYM_KING    EQU "K"
 = 00000051			SYM_QUEEN   EQU "Q"
 = 0000004E			SYM_KNIGHT  EQU "N"
 = 00000042			SYM_BISHOP  EQU "B"
 = 00000052			SYM_ROOK    EQU "R"
 = 00000070			SYM_PAWN    EQU "p"
 = 0000002D			SYM_BLANK   EQU "-"

				; Color - Used when printing the board
 = 00000080			IS_BLACK    EQU 10000000b

				; Piece Types
 = 00000001			KING    EQU 01h
 = 00000002			QUEEN   EQU 02h
 = 00000003			KNIGHT  EQU 03h
 = 00000004			BISHOP  EQU 04h
 = 00000005			ROOK    EQU 05h
 = 00000006			PAWN    EQU 06h

				; Special Conditions
 = 00000020			HAS_MOVED           EQU 00100000b
 = 00000010			IS_EN_PASSANTABLE   EQU 00010000b
 = 000000EF			NO_EN_PASSANT       EQU 11101111b

				; Movement Abilities
 = 00000001			DIAGONAL        EQU 00000001b
 = 00000002			PARALLEL        EQU 00000010b
 = 00000004			LSHAPE          EQU 00000100b
 = 00000008			FORWARD_ONLY    EQU 00001000b

				; Default Black Pieces
 = 00000081			BLACK_KING      EQU 81h
 = 00000082			BLACK_QUEEN     EQU 82h
 = 00000083			BLACK_KNIGHT    EQU 83h
 = 00000084			BLACK_BISHOP    EQU 84h
 = 00000085			BLACK_ROOK      EQU 85h
 = 00000086			BLACK_PAWN      EQU 86h

				; Game Status Flags
 = 00000001			BLACK_WON       EQU 00000001b
 = 00000002			GAMEOVER        EQU 00000010b
 = 00000008			IS_IN_CHECK     EQU 00001000b
 = 00000080			IS_BLACK_TURN   EQU 10000000b




 00000162			.data

 00000162 54 65 72 6D 69	    chess_title BYTE "Terminal Chess",0
	   6E 61 6C 20 43
	   68 65 73 73 00
 00000171  00000005 [		    userInput BYTE INPUT_SIZE DUP(0)
	    00
	   ]

				    ; 4 left bits hold max number of jumps, 4 right bits hold move abilities (diagonal, parallel, etc)
 00000176 13			    KING_MOVE BYTE      00010011b
 00000177 83			    QUEEN_MOVE BYTE     10000011b
 00000178 14			    KNIGHT_MOVE BYTE    00010100b
 00000179 81			    BISHOP_MOVE BYTE    10000001b
 0000017A 82			    ROOK_MOVE BYTE      10000010b
 0000017B 28			    PAWN_MOVE BYTE      00101000b

 0000017C 00			    GAME_STATUS BYTE 0
 0000017D 00			    FIFTY_MOVE_RULE BYTE 0

 0000017E  00000040 [		    CHESSBOARD BYTE 64 DUP(0)
	    00
	   ]
 000001BE  00000040 [		    CHESSBOARD_COPY BYTE 64 DUP(0)
	    00
	   ]

 00000000			.code

 00000000			main PROC
				    invoke SetConsoleTitle, OFFSET chess_title
 00000000  68 00000162 R   *	    push   dword  ptr OFFSET FLAT: chess_title
 00000005  E8 00000000 E   *	    call   SetConsoleTitleA
 0000000A			    PLAY_AGAIN:
 0000000A  E8 00000043		    call chess

 0000000F			    INVALID_MENU:
				    mwriteln<"Do you want to play again? [y/n]:  ">
 000001FE		     2		.data		
 000001FE 44 6F 20 79 6F     2		??0000 BYTE "Do you want to play again? [y/n]:  ",0	
	   75 20 77 61 6E
	   74 20 74 6F 20
	   70 6C 61 79 20
	   61 67 61 69 6E
	   3F 20 5B 79 2F
	   6E 5D 3A 20 20
	   00
 0000000F		     2		.code
 0000000F  52		     2		push	edx
 00000010  BA 000001FE R     2		mov	edx,OFFSET ??0000
 00000015  E8 00000000 E     2		call	WriteString
 0000001A  5A		     2		pop	edx
 0000001B  E8 00000000 E     1		call	Crlf
 00000020  BA 00000171 R	    mov edx, OFFSET userInput
 00000025  B9 00000005		    mov ecx, sizeof userInput
 0000002A  E8 00000000 E	    call ReadChar
 0000002F  E8 00000000 E	    call YesOrNo
 00000034  72 D4		    jc PLAY_AGAIN   ; if answer was y
 00000036  74 13		    jz QUIT_GAME    ; if answer was n

				    ; else input is invalid
				    mwriteln <"Invalid Input. Try again!">
 00000222		     2		.data		
 00000222 49 6E 76 61 6C     2		??0001 BYTE "Invalid Input. Try again!",0	
	   69 64 20 49 6E
	   70 75 74 2E 20
	   54 72 79 20 61
	   67 61 69 6E 21
	   00
 00000038		     2		.code
 00000038  52		     2		push	edx
 00000039  BA 00000222 R     2		mov	edx,OFFSET ??0001
 0000003E  E8 00000000 E     2		call	WriteString
 00000043  5A		     2		pop	edx
 00000044  E8 00000000 E     1		call	Crlf

 00000049  EB C4		    jmp INVALID_MENU

 0000004B			    QUIT_GAME:
				    exit
 0000004B  6A 00	   *	    push   +000000000h
 0000004D  E8 00000000 E   *	    call   ExitProcess

 00000052			main ENDP

 00000052			chess PROC
				    
				    ; Initialize Chessboard
 00000052  E8 0000053C		    call initChessboard

 00000057			    StartTurn:
 00000057  E8 00000000 E	        call Clrscr             ; Clear Screen
				        mGotoxy 0, 0            ; Move Console cursor to beginning
 0000005C  52		     1		push edx
 0000005D  B6 00	     1		mov  dh,0
 0000005F  B2 00	     1		mov  dl,0
 00000061  E8 00000000 E     1		call Gotoxy
 00000066  5A		     1		pop  edx
 00000067  E8 00000640		        call PrintChessboard
 0000006C  E8 000005E6		        call PrintWhoseTurn
				        PrintFeedback
 00000071  B8 00000004	     1	    mov eax, red + (black*16)
 00000076  E8 00000000 E     1	    call SetTextColor
 0000007B  A0 00000000 R     1	    mov al, FEEDBACK
 00000080  3C 00	     1	    cmp al, 0
 00000082  74 68	     1	    je SKIP_PRINT                   ; skip to end if there is no feedback
 00000084  3C 01	     1	    cmp al, INVALID_MOVE
 00000086  74 22	     1	    je INVALID_MOVE_F
 00000088  3C 02	     1	    cmp al, MOVE_OUTSIDE_RANGE
 0000008A  74 33	     1	    je MOVE_OUTSIDE_RANGE_F
 0000008C  3C 05	     1	    cmp al, MISMATCH_COLOR
 0000008E  74 21	     1	    je MISMATCH_COLOR_F
 00000090  3C 06	     1	    cmp al, MISMATCH_COLOR_CAPT
 00000092  74 24	     1	    je MISMATCH_COLOR_CAPT_F
 00000094  3C 07	     1	    cmp al, BLOCKED_PATH
 00000096  74 3C	     1	    je BLOCKED_PATH_F
 00000098  3C 03	     1	    cmp al, KING_LEFT_IN_CHECK
 0000009A  74 2A	     1	    je KING_LEFT_IN_CHECK_F
 0000009C  3C 04	     1	    cmp al, EMPTY_SQUARE_MOVE
 0000009E  74 2D	     1	    je EMPTY_SQUARE_MOVE_F
 000000A0  3C 08	     1	    cmp al, ERROR_PATH
 000000A2  74 3E	     1	    je ERROR_PATH_F
 000000A4  3C 09	     1	    cmp al, ERROR_KING_CAPTURE
 000000A6  74 33	     1	    je ERROR_KING_CAPTURE_F
 000000A8  EB 42	     1	    jmp SKIP_PRINT                  ; If no feedback was found, skip to the end
 000000AA		     1	    INVALID_MOVE_F:
 000000AA  BA 00000001 R     1	        mov edx, OFFSET INVALID_MOVE_STR
 000000AF  EB 36	     1	        jmp END_OF_FEEDBACK
 000000B1		     1	    MISMATCH_COLOR_F:
 000000B1  BA 0000006D R     1	        mov edx, OFFSET MISMATCH_COLOR_STR
 000000B6  EB 2F	     1	        jmp END_OF_FEEDBACK
 000000B8		     1	    MISMATCH_COLOR_CAPT_F:
 000000B8  BA 00000092 R     1	        mov edx, OFFSET MISMATCH_COLOR_CAPT_STR
 000000BD  EB 28	     1	        jmp END_OF_FEEDBACK
 000000BF		     1	    MOVE_OUTSIDE_RANGE_F:
 000000BF  BA 00000011 R     1	        mov edx, OFFSET MOVE_OUTSIDE_RANGE_STR
 000000C4  EB 21	     1	        jmp END_OF_FEEDBACK
 000000C6		     1	    KING_LEFT_IN_CHECK_F:
 000000C6  BA 00000033 R     1	        mov edx, OFFSET KING_LEFT_IN_CHECK_STR
 000000CB  EB 1A	     1	        jmp END_OF_FEEDBACK
 000000CD		     1	    EMPTY_SQUARE_MOVE_F:
 000000CD  BA 00000051 R     1	        mov edx, OFFSET EMPTY_SQUARE_MOVE_STR
 000000D2  EB 13	     1	        jmp END_OF_FEEDBACK
 000000D4		     1	    BLOCKED_PATH_F:
 000000D4  BA 000000BA R     1	        mov edx, OFFSET BLOCKED_PATH_STR
 000000D9  EB 0C	     1	        jmp END_OF_FEEDBACK
 000000DB		     1	    ERROR_KING_CAPTURE_F:
 000000DB  BA 00000125 R     1	        mov edx, OFFSET ERROR_KING_CAPTURE_STR
 000000E0  EB 05	     1	        jmp END_OF_FEEDBACK
 000000E2		     1	    ERROR_PATH_F:
 000000E2  BA 000000EE R     1	        mov edx, OFFSET ERROR_PATH_STR
 000000E7		     1	    END_OF_FEEDBACK:
 000000E7  E8 00000000 E     1	    call WriteString                ; Print out feedback in edx
 000000EC		     1	    SKIP_PRINT:
 000000EC  B8 0000000F	     1	    mov eax, white + (black*16)     ; Set text color back to white
 000000F1  E8 00000000 E     1	    call SetTextColor
 000000F6  C6 05 00000000 R  1	    mov FEEDBACK, 0
	   00
				    
 000000FD			    GET_INPUT:
				        ; Clear registers
 000000FD  B8 00000000		        mov eax, 0
 00000102  BB 00000000		        mov ebx, 0
 00000107  B9 00000000		        mov ecx, 0
 0000010C  BA 00000000		        mov edx, 0
 00000111  BE 00000000		        mov esi, 0
 00000116  BF 00000000		        mov edi, 0
 0000011B  E8 000003F2		        call GetChessInput  ; Ask the player for input
 00000120  E8 00000408		        call ProcessInput   ; Turns ascii input coords in userInput into range from 0-7
				        GetFeedback         ; move FEEDBACK Byte into al
 00000125  A0 00000000 R     1		mov al, FEEDBACK
 0000012A  3C 00		        cmp al, 0
 0000012C  0F 85 FFFFFF25	        jne StartTurn       ; If FEEDBACK != 0, restart turn

 00000132  E8 00000031		        call InputToMove    ; Check if move from source to destination is valid
				        GetFeedback         ; move FEEDBACK Byte into al
 00000137  A0 00000000 R     1		mov al, FEEDBACK
 0000013C  3C 00		        cmp al, 0
 0000013E  0F 85 FFFFFF13	        jne StartTurn       ; If FEEDBACK != 0, restart turn

 00000144  E8 0000029D		        call VerifyMove     ; Second round of input validation (Leaving king in check, etc)
				        GetFeedback         ; move FEEDBACK Byte into al
 00000149  A0 00000000 R     1		mov al, FEEDBACK
 0000014E  3C 00		        cmp al, 0
 00000150  0F 85 FFFFFF01	        jne StartTurn       ; If FEEDBACK != 0, restart turn

				    ; Switch turn
 00000156  A0 0000017C R	    mov al, GAME_STATUS
 0000015B  34 80		    xor al, IS_BLACK
 0000015D  A2 0000017C R	    mov GAME_STATUS, al
 00000162  E9 FFFFFEF0		    jmp StartTurn           ; Loop back if game not over
				    
 00000167  C3			    ret
 00000168			chess ENDP

				; Used in checking a move is valid
 00000168			InputToMove PROC uses edx ecx
 00000168  52		   *	    push   edx
 00000169  51		   *	    push   ecx
 0000016A  83 F9 00		    cmp ecx, 0
 0000016D  75 01		    jne SKIP_PUSH_EDI   ; If ecx != 0, don't push edi (This is true at the start of the turn. False when running this from VerifyMove)
 0000016F  57			    push edi            ; See VerifyMove to know why we push edi
 00000170			    SKIP_PUSH_EDI:
				    ; Get First Piece
 00000170  BE 00000171 R	    mov esi, OFFSET userInput
 00000175  8B 16		    mov edx, [esi]              ; Copies userInput (a2c4[0123] in memory -> 3c2a[3210] in edx)
 00000177  E8 000004AD		    call MoveSPointerToSquare   ; Move esi to the coords in dx

				    ; This only matters when verifying move, skip the piece if it's the one that was moved
 0000017C  3B F7		    cmp esi, edi
 0000017E  0F 84 00000201	    je SKIP

				    ; Remove IS_EN_PASSANTABLE (Pawns can only be en passanted the move after, so we're removing the attribute)
 00000184  8A 1E		    mov bl, [esi]
 00000186  80 E3 EF		    and bl, NO_EN_PASSANT
 00000189  88 1E		    mov BYTE PTR [esi], bl

				    ; Check piece type
 0000018B  8A 06		    mov al, [esi]               ; Get square info
 0000018D  24 0F		    and al, 0Fh                 ; Isolate piece type
 0000018F  3C 06		    cmp al, PAWN
 00000191  74 20		    je PAWN_LOGIC
 00000193  3C 02		    cmp al, QUEEN
 00000195  74 30		    je QUEEN_LOGIC
 00000197  3C 03		    cmp al, KNIGHT
 00000199  74 40		    je KNIGHT_LOGIC
 0000019B  3C 04		    cmp al, BISHOP
 0000019D  74 50		    je BISHOP_LOGIC
 0000019F  3C 05		    cmp al, ROOK
 000001A1  74 60		    je ROOK_LOGIC
 000001A3  3C 01		    cmp al, KING
 000001A5  74 70		    je KING_LOGIC

				    SetFeedback EMPTY_SQUARE_MOVE
 000001A7  C6 05 00000000 R  1		mov FEEDBACK, EMPTY_SQUARE_MOVE
	   04
 000001AE  E9 000001D2		    jmp SKIP
				    
 000001B3			    PAWN_LOGIC:
 000001B3  8A 1D 0000017B R	    mov bl, PAWN_MOVE
 000001B9  80 E3 0F		    and bl, 0Fh
 000001BC  8A 3D 0000017B R	    mov bh, PAWN_MOVE
 000001C2  C0 EF 04		    shr bh, 4
 000001C5  EB 62		    jmp AFTER_COPY_LOGIC
 000001C7			    QUEEN_LOGIC:
 000001C7  8A 1D 00000177 R	    mov bl, QUEEN_MOVE
 000001CD  80 E3 0F		    and bl, 0Fh
 000001D0  8A 3D 00000177 R	    mov bh, QUEEN_MOVE
 000001D6  C0 EF 04		    shr bh, 4
 000001D9  EB 4E		    jmp AFTER_COPY_LOGIC
 000001DB			    KNIGHT_LOGIC:
 000001DB  8A 1D 00000178 R	    mov bl, KNIGHT_MOVE
 000001E1  80 E3 0F		    and bl, 0Fh
 000001E4  8A 3D 00000178 R	    mov bh, KNIGHT_MOVE
 000001EA  C0 EF 04		    shr bh, 4
 000001ED  EB 3A		    jmp AFTER_COPY_LOGIC
 000001EF			    BISHOP_LOGIC:
 000001EF  8A 1D 00000179 R	    mov bl, BISHOP_MOVE
 000001F5  80 E3 0F		    and bl, 0Fh
 000001F8  8A 3D 00000179 R	    mov bh, BISHOP_MOVE
 000001FE  C0 EF 04		    shr bh, 4
 00000201  EB 26		    jmp AFTER_COPY_LOGIC
 00000203			    ROOK_LOGIC:
 00000203  8A 1D 0000017A R	    mov bl, ROOK_MOVE
 00000209  80 E3 0F		    and bl, 0Fh
 0000020C  8A 3D 0000017A R	    mov bh, ROOK_MOVE
 00000212  C0 EF 04		    shr bh, 4
 00000215  EB 12		    jmp AFTER_COPY_LOGIC
 00000217			    KING_LOGIC:
 00000217  8A 1D 00000176 R	    mov bl, KING_MOVE
 0000021D  80 E3 0F		    and bl, 0Fh
 00000220  8A 3D 00000176 R	    mov bh, KING_MOVE
 00000226  C0 EF 04		    shr bh, 4
				    
 00000229			    AFTER_COPY_LOGIC:
				    ; Check color of moving piece
 00000229  8A 06		    mov al, [esi]               ; Get square info
 0000022B  8A 25 0000017C R	    mov ah, GAME_STATUS         ; Get Game Status
 00000231  24 80		    and al, 80h                 ; Isolate piece's is_black bit
 00000233  80 E4 80		    and ah, 80h                 ; Isolate game status's is_black_turn bit
 00000236  32 C4		    xor al, ah                  ; Check if the color is the same
 00000238  74 0C		    jz SOURCE_CORRECT_COLOR     ; If same, continue

				    SetFeedback MISMATCH_COLOR
 0000023A  C6 05 00000000 R  1		mov FEEDBACK, MISMATCH_COLOR
	   05
 00000241  E9 0000013F		    jmp SKIP

 00000246			    SOURCE_CORRECT_COLOR:
				    ; Check destination square
 00000246  C1 CA 10		    ror edx, 16                 ; Switch dx to the destination square
 00000249  E8 000003F2		    call MoveDPointerToSquare
 0000024E  C1 CA 10		    ror edx, 16                 ; Switch dx back to source square

				    ; Check if there is a piece there
 00000251  8A 07		    mov al, [edi]               ; Get destination square info
 00000253  24 0F		    and al, 0Fh                 ; Isolate piece type
 00000255  3C 00		    cmp al, 0
 00000257  75 02		    jne CHECK_COLOR             ; If al != 0 (not empty), check color

 00000259  EB 14		    jmp DONT_CHECK_COLOR

 0000025B			    CHECK_COLOR:
				    ; (ah already has game status's color bit from earlier)
 0000025B  8A 07		    mov al, [edi]               ; Get destination square info
 0000025D  24 80		    and al, 80h                 ; Isolate is_black bit
 0000025F  32 C4		    xor al, ah                  ; Check if the color is the same
 00000261  75 0C		    jnz DONT_CHECK_COLOR        ; If different, continue

				    SetFeedback MISMATCH_COLOR_CAPT
 00000263  C6 05 00000000 R  1		mov FEEDBACK, MISMATCH_COLOR_CAPT
	   06
 0000026A  E9 00000116		    jmp SKIP

 0000026F			    DONT_CHECK_COLOR:
 0000026F  E8 00000000 E	    call GetCoordsDifference    ; Get difference in coords. al(x) and ah(y) are normal, cl(x) and ch(y) are absolute value
 00000274  F6 C3 01		    test bl, DIAGONAL
 00000277  75 1B		    jnz DIAGONAL_LOGIC
 00000279			    DIAGONAL_RET:

 00000279  F6 C3 02		    test bl, PARALLEL
 0000027C  75 29		    jnz PARALLEL_LOGIC
 0000027E			    PARALLEL_RET:

 0000027E  F6 C3 04		    test bl, LSHAPE
 00000281  75 4D		    jnz LSHAPE_LOGIC
 00000283			    LSHAPE_RET:

 00000283  F6 C3 08		    test bl, FORWARD_ONLY
 00000286  75 6C		    jnz FORWARD_ONLY_LOGIC
 00000288			    FORWARD_ONLY_RET:

				    SetFeedback INVALID_MOVE
 00000288  C6 05 00000000 R  1		mov FEEDBACK, INVALID_MOVE
	   01
 0000028F  E9 000000F1		    jmp SKIP


				    ;   DIAGONAL LOGIC   ;
				    ; To check if it's diagonal, we want to know if abs x == abs y
 00000294			    DIAGONAL_LOGIC:

 00000294  3A CD		    cmp cl, ch                  ; Compare change in x with change in y
 00000296  75 E1		    jne DIAGONAL_RET            ; If not equal, go back and check other move types

				    ; normalize vectors (make them equal 1 but keep sign)
 00000298  E8 00000000 E	    call NormalizeVectors
 0000029D  E8 000000EC		    call CheckPath      ; Check path
 000002A2  E9 000000DE		    jmp SKIP
				    

				    ;   PARALLEL LOGIC   ;
				    ; To check if it's parallel, we want to know if either x or y is 0 and the other is non 0
				    ; I'm just gonna check if cx greater than 7, if not, rotate the bits and check again
				    ; EX: 05 00h > 7 so rotate bits, now 00 05h <= 7
 000002A7			    PARALLEL_LOGIC:

 000002A7  66| 83 F9 07		    cmp cx, 7
 000002AB  7F 02		    jg FLIP             ; If cx > 7, go rotate bits
				    
 000002AD  EB 12		    jmp IS_PARALLEL

 000002AF			    FLIP:
 000002AF  66| C1 C9 08		    ror cx, 8           ; rotate bits
 000002B3  66| 83 F9 07		    cmp cx, 7
 000002B7  66| C1 C9 08		    ror cx, 8           ; undo in case of return
 000002BB  7F C1		    jg PARALLEL_RET     ; If c > 7, go back and check other move types
				    
 000002BD  66| C1 C9 08		    ror cx, 8           ; redo so non 0 is in cl (CheckPath needs this)
 000002C1			    IS_PARALLEL:
				    ; normalize vectors al and ah
 000002C1  E8 00000000 E	    call NormalizeVectors
 000002C6  E8 000000C3		    call CheckPath      ; Check path
 000002CB  E9 000000B5		    jmp SKIP


				    ;   LSHAPE LOGIC   ;
				    ; To check if it's L-shaped, we want to know if x and y have a 2:1 ratio
 000002D0			    LSHAPE_LOGIC:
				    ; I'm doing a similar trick to parallel
 000002D0  66| 81 F9 0201	    cmp cx, 0201h
 000002D5  75 02		    jne FLIP2           ; If cx != 0201h, go rotate bits
				    
 000002D7  EB 11		    jmp IS_LSHAPE

 000002D9			    FLIP2:
 000002D9  66| C1 C9 08		    ror cx, 8           ; rotate bits
 000002DD  66| 81 F9 0201	    cmp cx, 0201h
 000002E2  66| C1 C9 08		    ror cx, 8           ; undo in case of return
 000002E6  75 9B		    jne LSHAPE_RET      ; If cx != 0201h, go back and check other move types
				    
 000002E8  B1 01		    mov cl, 1           ; cl = 1 (CheckPath needs this)
 000002EA			    IS_LSHAPE:

 000002EA  E8 0000009F		    call CheckPath      ; Check path
 000002EF  E9 00000091		    jmp SKIP


				    ;   FORWARD ONLY LOGIC   ;
				    ; To check if it's Forward Only, we want to know if y changes, but x is 0
 000002F4			    FORWARD_ONLY_LOGIC:
				    ; Check for a single jump or a double jump
 000002F4  F6 C5 01		    test ch, 1
 000002F7  74 40		    jz CHECK_DOUBLE         ; If change in y != 1, check double jump

				    ; else check if capture
 000002F9  66| 81 F9 0100	    cmp cx, 0100h
 000002FE  74 4F		    je CHECK_DIRECTION      ; If change in y == 1 AND change in y == 0, continue
 00000300  66| 81 F9 0101	    cmp cx, 0101h
 00000305  75 81		    jne FORWARD_ONLY_RET    ; If change in y != 1 OR change in y != 1, go back and give feedback

				    ; else check if valid capture
 00000307  8A 17		    mov dl, [edi]
 00000309  F6 C2 0F		    test dl, 0Fh            
 0000030C  75 41		    jnz CHECK_DIRECTION         ; If square not empty, continue (Normal capture)

 0000030E  8B FE		    mov edi, esi                ; Move edi to esi
 00000310  0F BE D0		    movsx edx, al               
 00000313  F7 DA		    neg edx
 00000315  03 FA		    add edi, edx                ; add change in x to edi (En passant checks for piece next to pawn)

 00000317  8A 17		    mov dl, [edi]
 00000319  F6 C2 10		    test dl, IS_EN_PASSANTABLE
 0000031C  0F 84 FFFFFF66	    jz FORWARD_ONLY_RET         ; If piece next to pawn can't be en passanted, go back and give feedback

 00000322  8A 17		    mov dl, [edi]               ; Get square info
 00000324  8A 35 0000017C R	    mov dh, GAME_STATUS         ; Get Game Status
 0000032A  80 E2 80		    and dl, 80h                 ; Isolate piece's is_black bit
 0000032D  80 E6 80		    and dh, 80h                 ; Isolate game status's is_black_turn bit
 00000330  32 D6		    xor dl, dh                  ; Check if the color is different
 00000332  75 1B		    jnz CHECK_DIRECTION         ; If color is different, continue
				    
 00000334  E9 FFFFFF4F		    jmp FORWARD_ONLY_RET        ; else go back and give feedback

 00000339			    CHECK_DOUBLE:
 00000339  66| 81 F9 0200	    cmp cx, 0200h
 0000033E  0F 85 FFFFFF44	    jne FORWARD_ONLY_RET        ; If change in y != 2 OR change in x != 0, go back and give feedback
 00000344  8A 16		    mov dl, [esi]
 00000346  F6 C2 20		    test dl, HAS_MOVED
 00000349  0F 85 FFFFFF39	    jnz FORWARD_ONLY_RET         ; If has moved already, go back and give feedback

 0000034F			    CHECK_DIRECTION:
 0000034F  8A F4		    mov dh, ah              ; move ah to dh
 00000351  8A 15 0000017C R	    mov dl, GAME_STATUS
 00000357  80 E2 80		    and dl, 80h             ; Isolate game status's IS_BLACK_TURN bit
 0000035A  32 35 0000017C R	    xor dh, GAME_STATUS     ; bit is 1 when correct direction
 00000360  80 E6 80		    and dh, IS_BLACK_TURN   ; Checks if bit is 1 or 0
 00000363  0F 84 FFFFFF1F	    jz FORWARD_ONLY_RET     ; If incorrect direction, go back and give feedback

				    ; Final check, if move isn't diagonal and there's a piece ahead, don't capture
 00000369  80 F9 00		    cmp cl, 0
 0000036C  75 0B		    jne F_ONLY_CONTINUE     ; If horizontal movement not 0, continue

				    ; else check destination
 0000036E  8A 17		    mov dl, [edi]
 00000370  F6 C2 FF		    test dl, 0FFh
 00000373  0F 85 FFFFFF0F	    jnz FORWARD_ONLY_RET    ; If square not empty, go back and give feedback
				    
 00000379			    F_ONLY_CONTINUE:
 00000379  8A CD		    mov cl, ch              ; CheckPath uses cl as the loop condition, so put the forward jump distance into it

				    ; normalize vectors
 0000037B  E8 00000000 E	    call NormalizeVectors
 00000380  E8 00000009		    call CheckPath

 00000385			    SKIP:
 00000385  83 F9 00		    cmp ecx, 0
 00000388  75 01		    jne SKIP_POP_EDI
 0000038A  5F			    pop edi
 0000038B			    SKIP_POP_EDI:
				    ret
 0000038B  59		   *	    pop    ecx
 0000038C  5A		   *	    pop    edx
 0000038D  C3		   *	    ret    00000h
 0000038E			InputToMove ENDP

				; Checks the path between source and destination to see if it's valid
				; Inputs: esi starting position, edi ending position, ah y jump direction, al x jump direction, cl number of jumps, bh max number of jumps for piece type
 0000038E			CheckPath PROC
				    ; Since we did x1-x2 and y1-y2 before, we have to invert the signs
				    ; But since visually rows are in inverse position than they are in the array,
				    ; we don't flip the y jump direction (Look at MoveSPointerToSquare for more info)
 0000038E  F6 D8		    neg al

 00000390  56			    push esi

 00000391  C0 E4 03		    sal ah, 3           ; multiply row by 2^3 = 8
 00000394  3A CF		    cmp cl, bh
 00000396  7F 02		    jg MOVE_IS_INVALID  ; If # of jumps is greater than max, give feedback

 00000398  EB 09		    jmp LOOP_START      ; else skip feedback and continue

 0000039A			    MOVE_IS_INVALID:
				    SetFeedback INVALID_MOVE
 0000039A  C6 05 00000000 R  1		mov FEEDBACK, INVALID_MOVE
	   01
 000003A1  EB 41		    jmp SKIP

 000003A3			    LOOP_START:
				    ; Searching through path
 000003A3  0F BE D4		    movsx edx, ah
 000003A6  03 F2		    add esi, edx                ; Move over row
 000003A8  0F BE D0		    movsx edx, al
 000003AB  03 F2		    add esi, edx                ; Move over column

 000003AD  8A 16		    mov dl, [esi]               ; Get next square in path

 000003AF  FE C9		    dec cl
 000003B1  74 0E		    jz AFTER_LOOP               ; If we have no more jumps, go to end of loop

 000003B3  F6 C2 0F		    test dl, 0Fh        
 000003B6  74 EB		    jz LOOP_START               ; If not a piece, continue loop

				    SetFeedback BLOCKED_PATH    ; else set feedback and go back
 000003B8  C6 05 00000000 R  1		mov FEEDBACK, BLOCKED_PATH
	   07
 000003BF  EB 23		    jmp SKIP

 000003C1			    AFTER_LOOP:

 000003C1  3B F7		    cmp esi, edi    
 000003C3  74 10		    je KING_CHECK               ; If source and destination are equal, continue

 000003C5  8A 17		    mov dl, [edi]               ; Else check en passant
 000003C7  F6 C2 10		    test dl, IS_EN_PASSANTABLE
 000003CA  75 18		    jnz SKIP                    ; If en passantable, continue (Don't bother checking for king, king will never be en passantable)

				    SetFeedback ERROR_PATH      ; else set feedback and go back
 000003CC  C6 05 00000000 R  1		mov FEEDBACK, ERROR_PATH
	   08
 000003D3  EB 0F		    jmp SKIP

				    ; Check if king is trying to be captured
 000003D5			    KING_CHECK:
 000003D5  8A 07		    mov al, [edi]                       ; Get square info
 000003D7  24 0F		    and al, 0Fh                         ; Isolate piece type
 000003D9  3C 01		    cmp al, KING
 000003DB  75 07		    jne SKIP                            ; If not trying to capture king, continue

				    SetFeedback ERROR_KING_CAPTURE      ; Else give feedback
 000003DD  C6 05 00000000 R  1		mov FEEDBACK, ERROR_KING_CAPTURE
	   09

 000003E4			    SKIP:
 000003E4  5E			    pop esi
 000003E5  C3			    ret
 000003E6			CheckPath ENDP

				; Confirms that the move is valid by testing it on a copy of the chessboard
				; If it is, do the move. if it isn't, produce feedback
 000003E6			VerifyMove PROC
				    ; Make a copy of the chessboard
 000003E6  56			    push esi
 000003E7  57			    push edi

 000003E8  BE 0000017E R	    mov esi, OFFSET CHESSBOARD
 000003ED  BF 000001BE R	    mov edi, OFFSET CHESSBOARD_COPY

 000003F2  B1 40		    mov cl, 64
 000003F4			    LOOP_START:
 000003F4  8A 2E		    mov ch, [esi]
 000003F6  88 2F		    mov BYTE PTR [edi], ch

 000003F8  46			    inc esi
 000003F9  47			    inc edi
 000003FA  FE C9		    dec cl
 000003FC  75 F6		    jnz LOOP_START
				    
 000003FE  5F			    pop edi
 000003FF  5E			    pop esi
				  
				    ; Mark the piece as en passant if it's a pawn and a double square jump
 00000400  8A 06		    mov al, [esi]
 00000402  24 0F		    and al, 0Fh
 00000404  3C 06		    cmp al, PAWN
 00000406  75 16		    jne CHECK_MOVE_TYPE     ; If not a pawn, continue to CHECK_MOVE_TYPE
 00000408  8B DE		    mov ebx, esi
 0000040A  2B DF		    sub ebx, edi
 0000040C  83 FB 10		    cmp ebx, 16
 0000040F  74 07		    je SET_EN_PASSANT
 00000411  F7 DB		    neg ebx
 00000413  83 FB 10		    cmp ebx, 16
 00000416  75 06		    jne CHECK_MOVE_TYPE
				    
 00000418			    SET_EN_PASSANT:
 00000418  8A 06		    mov al, [esi]
 0000041A  0C 10		    or al, IS_EN_PASSANTABLE
 0000041C  88 06		    mov BYTE PTR [esi], al

 0000041E			    CHECK_MOVE_TYPE:
 0000041E  8A 07		    mov al, [edi]      
 00000420  A8 10		    test al, IS_EN_PASSANTABLE
 00000422  74 13		    jz NORMAL_MOVE              ; If destination square is not en passantable, go to NORMAL_MOVE

 00000424  8A 06		    mov al, [esi]               
 00000426  0C 20		    or al, HAS_MOVED            ; Mark HAS_MOVED bit for moving piece
 00000428  C6 06 00		    mov BYTE PTR [esi], 0
 0000042B  C6 07 00		    mov BYTE PTR [edi], 0
 0000042E  0F BE CC		    movsx ecx, ah               
 00000431  03 F9		    add edi, ecx                ; Move destination pointer forward one row
 00000433  88 07		    mov BYTE PTR [edi], al
 00000435  EB 09		    jmp START_KING_SEARCH

 00000437			    NORMAL_MOVE:
 00000437  8A 06		    mov al, [esi]
 00000439  0C 20		    or al, HAS_MOVED            ; Mark HAS_MOVED bit for moving piece
 0000043B  88 07		    mov BYTE PTR [edi], al      ; Overwrite destination with moving piece
 0000043D  C6 06 00		    mov BYTE PTR [esi], 0       ; Cover up tracks

 00000440			    START_KING_SEARCH:
 00000440  BE 0000017E R	    mov esi, OFFSET CHESSBOARD
 00000445  B1 40		    mov cl, 64
				    
 00000447			    KING_SEARCH:
 00000447  8A 06		    mov al, [esi]
 00000449  24 0F		    and al, 0Fh
 0000044B  3C 01		    cmp al, KING
 0000044D  74 02		    je IS_KING

 0000044F  EB 13		    jmp SKIP_KING

 00000451			    IS_KING:
 00000451  8A 06		    mov al, [esi]
 00000453  8A 25 0000017C R	    mov ah, GAME_STATUS
 00000459  24 80		    and al, 80h
 0000045B  80 E4 80		    and ah, 80h
 0000045E  32 C4		    xor al, ah
 00000460  75 02		    jnz SKIP_KING

 00000462  EB 05		    jmp END_KING_SEARCH
				    
 00000464			    SKIP_KING:
 00000464  46			    inc esi
 00000465  FE C9		    dec cl
 00000467  75 DE		    jnz KING_SEARCH

 00000469			    END_KING_SEARCH:
 00000469  8B DE		    mov ebx, esi
 0000046B  81 EB 0000017E R	    sub ebx, OFFSET CHESSBOARD
 00000471  83 E3 07		    and ebx, 00000111b          ; Isolate column
				    
 00000474  8A D3		    mov dl, bl

 00000476  8B DE		    mov ebx, esi
 00000478  81 EB 0000017E R	    sub ebx, OFFSET CHESSBOARD
 0000047E  81 E3 000000F8	    and ebx, 11111000b          ; Isolate row
 00000484  C1 E3 05		    shl ebx, 5                  ; Shift left to have number of rows in bh
				    
 00000487  8A F7		    mov dh, bh
				    ; flip row
 00000489  80 EE 07		    sub dh, 7
 0000048C  F6 DE		    neg dh

 0000048E  88 15 00000173 R	    mov [userInput+2], dl 
 00000494  88 35 00000174 R	    mov [userInput+3], dh 
 0000049A  C1 CA 10		    ror edx, 16                 ; Rotate king position to the destination side of edx
				    
				    ; Now we're going to loop through all pieces and see if they have a valid path to the king
				    ; Temp change to other color so the input validation doesn't get in the way
 0000049D  A0 0000017C R	    mov al, GAME_STATUS
 000004A2  34 80		    xor al, IS_BLACK
 000004A4  A2 0000017C R	    mov GAME_STATUS, al

 000004A9  BE 0000017E R	    mov esi, OFFSET CHESSBOARD
 000004AE  B2 07		    mov dl, 7
 000004B0  B6 07		    mov dh, 7
				    
 000004B2			    CHECK_FOR_ATTACKER:
 000004B2  88 15 00000171 R	    mov [userInput], dl 
 000004B8  88 35 00000172 R	    mov [userInput+1], dh
 000004BE  E8 FFFFFCA5		    call InputToMove
				    GetFeedback
 000004C3  A0 00000000 R     1		mov al, FEEDBACK
 000004C8  3C 09		    cmp al, ERROR_KING_CAPTURE
 000004CA  74 13		    je IS_ATTACKER

 000004CC			    SKIP_PIECE:
				    SetFeedback 0
 000004CC  C6 05 00000000 R  1		mov FEEDBACK, 0
	   00
 000004D3  FE CA		    dec dl
 000004D5  79 DB		    jns CHECK_FOR_ATTACKER
 000004D7  B2 07		    mov dl, 7
 000004D9  FE CE		    dec dh
 000004DB  79 D5		    jns CHECK_FOR_ATTACKER

 000004DD  EB 1F		    jmp END_ATTACKER_SEARCH

 000004DF			    IS_ATTACKER:
				    SetFeedback KING_LEFT_IN_CHECK
 000004DF  C6 05 00000000 R  1		mov FEEDBACK, KING_LEFT_IN_CHECK
	   03
				    ; UNDO CHANGE
 000004E6  BE 0000017E R	    mov esi, OFFSET CHESSBOARD
 000004EB  BF 000001BE R	    mov edi, OFFSET CHESSBOARD_COPY

 000004F0  B1 40		    mov cl, 64
 000004F2			    UNDO_START:
 000004F2  8A 2F		    mov ch, [edi]
 000004F4  88 2E		    mov BYTE PTR [esi], ch

 000004F6  46			    inc esi
 000004F7  47			    inc edi
 000004F8  FE C9		    dec cl
 000004FA  75 F6		    jnz UNDO_START
 000004FC  EB 07		    jmp SKIP

 000004FE			    END_ATTACKER_SEARCH:
				    SetFeedback 0
 000004FE  C6 05 00000000 R  1		mov FEEDBACK, 0
	   00

 00000505			    SKIP:
 00000505  A0 0000017C R	    mov al, GAME_STATUS
 0000050A  34 80		    xor al, IS_BLACK
 0000050C  A2 0000017C R	    mov GAME_STATUS, al
 00000511  C3			    ret
 00000512			VerifyMove ENDP

				; Simply gets the input from user and puts it in userInput
 00000512			GetChessInput PROC
				    mGotoxy 17,20               ; Move cursor after label "Enter your move: "
 00000512  52		     1		push edx
 00000513  B6 14	     1		mov  dh,20
 00000515  B2 11	     1		mov  dl,17
 00000517  E8 00000000 E     1		call Gotoxy
 0000051C  5A		     1		pop  edx

 0000051D  BA 00000171 R	    mov edx, OFFSET userInput   ; ReadString takes edx as address
 00000522  B9 00000005		    mov ecx, INPUT_SIZE         ; ReadString takes ecx as the input size
 00000527  E8 00000000 E	    call ReadString

 0000052C  C3			    ret
 0000052D			GetChessInput ENDP

				; Gets input from userInput and converts the ascii characters to chessboard coords
 0000052D			ProcessInput PROC
				    ; Convert characters to decimal values
				    ; Letter
 0000052D  A0 00000171 R	    mov al, [userInput]     ; First char
 00000532  2C 61		    sub al, 97              
 00000534  7C 55		    jl RANGE_ERROR          ; Check if it goes below 0
 00000536  A2 00000171 R	    mov [userInput], al
				    ; Number
 0000053B  A0 00000172 R	    mov al, [userInput+1]   ; Second char
 00000540  2C 31		    sub al, 49
 00000542  7C 47		    jl RANGE_ERROR          ; Check if it goes below 0
 00000544  A2 00000172 R	    mov [userInput+1], al
				    ; Letter
 00000549  A0 00000173 R	    mov al, [userInput+2]   ; Third char
 0000054E  2C 61		    sub al, 97
 00000550  7C 39		    jl RANGE_ERROR          ; Check if it goes below 0
 00000552  A2 00000173 R	    mov [userInput+2], al
				    ; Number
 00000557  A0 00000174 R	    mov al, [userInput+3]   ; Fourth char
 0000055C  2C 31		    sub al, 49
 0000055E  7C 2B		    jl RANGE_ERROR          ; Check if it goes below 0
 00000560  A2 00000174 R	    mov [userInput+3], al


				    ; Check if it is above 7
 00000565  A0 00000171 R	    mov al, [userInput]
 0000056A  3C 07		    cmp al, 7
 0000056C  7F 1D		    jg RANGE_ERROR
 0000056E  A0 00000172 R	    mov al, [userInput+1]
 00000573  3C 07		    cmp al, 7
 00000575  7F 14		    jg RANGE_ERROR
 00000577  A0 00000173 R	    mov al, [userInput+2]
 0000057C  3C 07		    cmp al, 7
 0000057E  7F 0B		    jg RANGE_ERROR
 00000580  A0 00000174 R	    mov al, [userInput+3]
 00000585  3C 07		    cmp al, 7
 00000587  7F 02		    jg RANGE_ERROR

 00000589  EB 07		    jmp SKIP    ; Everything checks out, we can continue

 0000058B			    RANGE_ERROR:
				    SetFeedback MOVE_OUTSIDE_RANGE
 0000058B  C6 05 00000000 R  1		mov FEEDBACK, MOVE_OUTSIDE_RANGE
	   02

 00000592			    SKIP:
 00000592  C3			    ret
 00000593			ProcessInput ENDP

 00000593			InitChessboard PROC

				    ; BLACK
 00000593  C6 05 0000017E R	    mov [CHESSBOARD+0], BLACK_ROOK
	   85
 0000059A  C6 05 0000017F R	    mov [CHESSBOARD+1], BLACK_KNIGHT
	   83
 000005A1  C6 05 00000180 R	    mov [CHESSBOARD+2], BLACK_BISHOP
	   84
 000005A8  C6 05 00000181 R	    mov [CHESSBOARD+3], BLACK_QUEEN
	   82
 000005AF  C6 05 00000182 R	    mov [CHESSBOARD+4], BLACK_KING
	   81
 000005B6  C6 05 00000183 R	    mov [CHESSBOARD+5], BLACK_BISHOP
	   84
 000005BD  C6 05 00000184 R	    mov [CHESSBOARD+6], BLACK_KNIGHT
	   83
 000005C4  C6 05 00000185 R	    mov [CHESSBOARD+7], BLACK_ROOK
	   85

 000005CB  B1 08		    mov cl, 8
 000005CD  BE 00000186 R	    mov esi, OFFSET [CHESSBOARD+8]

 000005D2			    PlaceBlackPawns:
 000005D2  C6 06 86		    mov BYTE PTR [esi], BLACK_PAWN
 000005D5  46			    inc esi
 000005D6  FE C9		    dec cl
 000005D8  75 F8		    jnz PlaceBlackPawns

				    ; WHITE
 000005DA  C6 05 00000196 R	    mov [CHESSBOARD+24], PAWN
	   06
 000005E1  C6 05 000001B6 R	    mov [CHESSBOARD+56], ROOK
	   05
 000005E8  C6 05 000001B7 R	    mov [CHESSBOARD+57], KNIGHT
	   03
 000005EF  C6 05 000001B8 R	    mov [CHESSBOARD+58], BISHOP
	   04
 000005F6  C6 05 000001B9 R	    mov [CHESSBOARD+59], QUEEN
	   02
 000005FD  C6 05 000001BA R	    mov [CHESSBOARD+60], KING
	   01
 00000604  C6 05 000001BB R	    mov [CHESSBOARD+61], BISHOP
	   04
 0000060B  C6 05 000001BC R	    mov [CHESSBOARD+62], KNIGHT
	   03
 00000612  C6 05 000001BD R	    mov [CHESSBOARD+63], ROOK
	   05

 00000619  B1 08		    mov cl, 8
 0000061B  BE 000001AE R	    mov esi, OFFSET [CHESSBOARD+48]

 00000620			    PlaceWhitePawns:
 00000620  C6 06 06		    mov BYTE PTR [esi], PAWN
 00000623  46			    inc esi
 00000624  FE C9		    dec cl
 00000626  75 F8		    jnz PlaceWhitePawns

 00000628  C3			    ret
 00000629			InitChessboard ENDP

				; Takes chess input in dx (dh is row, dl is column)
				; and sets esi to the square
 00000629			MoveSPointerToSquare PROC
 00000629  50			    push eax

 0000062A  0F BE C6		    movsx eax, dh               ; Copy row

				    ; Visually row 8 is actually the start of the array (If confused, look at chessboard from white's pov, the array goes from left to right, top to bottom)
				    ; so we have to invert the row number to get the row number in the array
 0000062D  83 E8 07		    sub eax, 7
 00000630  F7 D8		    neg eax
 00000632  C1 E0 03		    shl eax, 3                  ; multiply row by 2^3 = 8
 00000635  02 C2		    add al, dl                  ; add column

 00000637  BE 0000017E R	    mov esi, OFFSET CHESSBOARD  ; Move source pointer to chessboard
 0000063C  03 F0		    add esi, eax                ; Go to square

 0000063E  58			    pop eax
 0000063F  C3			    ret
 00000640			MoveSPointerToSquare ENDP

				; Takes chess input in dx (dh is row, dl is column)
				; and sets edi to the square
 00000640			MoveDPointerToSquare PROC
 00000640  50			    push eax
 00000641  0F BE C6		    movsx eax, dh               ; Copy row

				    ; Refer to MoveSPointerToSquare just above this Procedure
 00000644  83 E8 07		    sub eax, 7
 00000647  F7 D8		    neg eax
 00000649  C1 E0 03		    shl eax, 3                  ; multiply row by 2^3 = 8
 0000064C  02 C2		    add al, dl                  ; add column

 0000064E  BF 0000017E R	    mov edi, OFFSET CHESSBOARD  ; Move source pointer to chessboard
 00000653  03 F8		    add edi, eax                ; Go to square

 00000655  58			    pop eax
 00000656  C3			    ret
 00000657			MoveDPointerToSquare ENDP

				; Simply prints a label saying whose turn it is
 00000657			PrintWhoseTurn PROC
 00000657  A0 0000017C R	    mov al, GAME_STATUS
 0000065C  A8 80		    test al, IS_BLACK_TURN
 0000065E  75 13		    jnz BLACK_TURN

				    mWriteln <"White's turn">
 0000023C		     2		.data		
 0000023C 57 68 69 74 65     2		??0002 BYTE "White's turn",0	
	   27 73 20 74 75
	   72 6E 00
 00000660		     2		.code
 00000660  52		     2		push	edx
 00000661  BA 0000023C R     2		mov	edx,OFFSET ??0002
 00000666  E8 00000000 E     2		call	WriteString
 0000066B  5A		     2		pop	edx
 0000066C  E8 00000000 E     1		call	Crlf
 00000671  EB 11		    jmp SKIP

 00000673			    BLACK_TURN:
				    mWriteln <"Black's turn">
 00000249		     2		.data		
 00000249 42 6C 61 63 6B     2		??0003 BYTE "Black's turn",0	
	   27 73 20 74 75
	   72 6E 00
 00000673		     2		.code
 00000673  52		     2		push	edx
 00000674  BA 00000249 R     2		mov	edx,OFFSET ??0003
 00000679  E8 00000000 E     2		call	WriteString
 0000067E  5A		     2		pop	edx
 0000067F  E8 00000000 E     1		call	Crlf

 00000684			    SKIP:
				    mWriteln <"------------">
 00000256		     2		.data		
 00000256 2D 2D 2D 2D 2D     2		??0004 BYTE "------------",0	
	   2D 2D 2D 2D 2D
	   2D 2D 00
 00000684		     2		.code
 00000684  52		     2		push	edx
 00000685  BA 00000256 R     2		mov	edx,OFFSET ??0004
 0000068A  E8 00000000 E     2		call	WriteString
 0000068F  5A		     2		pop	edx
 00000690  E8 00000000 E     1		call	Crlf
				    mWriteln <"Enter your move: ">
 00000263		     2		.data		
 00000263 45 6E 74 65 72     2		??0005 BYTE "Enter your move: ",0	
	   20 79 6F 75 72
	   20 6D 6F 76 65
	   3A 20 00
 00000695		     2		.code
 00000695  52		     2		push	edx
 00000696  BA 00000263 R     2		mov	edx,OFFSET ??0005
 0000069B  E8 00000000 E     2		call	WriteString
 000006A0  5A		     2		pop	edx
 000006A1  E8 00000000 E     1		call	Crlf
 000006A6  E8 00000000 E	    call crlf
 000006AB  C3			    ret
 000006AC			PrintWhoseTurn ENDP

				; Prints the chessboard
 000006AC			PrintChessboard PROC

 000006AC  B1 08		    mov cl, 8                   ; cl: columns
 000006AE  B5 08		    mov ch, 8                   ; ch: rows
 000006B0  B2 01		    mov dl, 1                   ; dl: incrementer for row/column labels
 000006B2  BB 00000001		    mov ebx, 1                  ; ebx: incrementer for esi

 000006B7  A0 0000017C R	    mov al, GAME_STATUS         ; Get whose turn
 000006BC  A8 80		    test al, IS_BLACK_TURN
 000006BE  75 0B		    jnz PrintBlackTurn          ; If black's turn, go to PrintBlackTurn

 000006C0			    PrintWhiteTurn:
 000006C0  BE 0000017E R	        mov esi, OFFSET CHESSBOARD  ; Move source pointer to start of chessboard
 000006C5  B6 08		        mov dh, 8                   ; Row labels start at 8...
 000006C7  F6 DA		        neg dl                      ; and count down
 000006C9  EB 09		        jmp RowStart

 000006CB			    PrintBlackTurn:
 000006CB  BE 000001BD R	        mov esi, OFFSET CHESSBOARD+63   ; Move source pointer to end of chessboard
 000006D0  B6 01		        mov dh, 1                       ; Row labels start at 1 and count up
 000006D2  F7 DB		        neg ebx                         ; but esi counts down

				    ; print the row number
 000006D4			    RowStart:
 000006D4  B8 0000000F		        mov eax, white + (black*16) ; Set Text color to white
 000006D9  E8 00000000 E	        call SetTextColor
 000006DE  0F B6 C6		        movzx eax, dh               
 000006E1  E8 00000000 E	        call WriteDec               ; Print Row Label
				        mWrite <"   ">
 00000275		     1		.data		
 00000275 20 20 20 00	     1		??0006 BYTE "   ",0	
 000006E6		     1		.code
 000006E6  52		     1		push	edx
 000006E7  BA 00000275 R     1		mov	edx,OFFSET ??0006
 000006EC  E8 00000000 E     1		call	WriteString
 000006F1  5A		     1		pop	edx

 000006F2			    PieceStart:
 000006F2  E8 0000005A		        call PrintPiece             ; Print piece

 000006F7  03 F3		        add esi, ebx                ; increment ebx
 000006F9  FE C9		        dec cl                      ; decrement column counter
 000006FB  75 F5		        jnz PieceStart              ; If cl != 0, continue printing pieces
 000006FD  E8 00000000 E	        call crlf
 00000702  E8 00000000 E	        call crlf
 00000707  B1 08		        mov cl, 8                   ; reset column counter
 00000709  02 F2		        add dh, dl                  ; increment row label
 0000070B  FE CD		        dec ch                      ; decrement row counter
 0000070D  75 C5		        jnz RowStart                ; if ch != 0, continue printing rows

				    ; Set Text color to white
 0000070F  B8 0000000F		    mov eax, white + (black*16)
 00000714  E8 00000000 E	    call SetTextColor

				    ; Print the column labels
 00000719  F6 DA		    neg dl                  ; Flip label incrementer...
 0000071B  02 F2		    add dh, dl              ; and undo the last add (this is important)
 0000071D  B1 08		    mov cl, 8               ; reset column counter

 0000071F  8A C6		    mov al, dh              ; White's view: dh = 1. Black's view: dh = 8 (without the undo, it would be 0 and 9)
 00000721  04 60		    add al, 96              ; 'a' - 1

				    mWrite <"x   ">         ; Print corner
 00000279		     1		.data		
 00000279 78 20 20 20 00     1		??0007 BYTE "x   ",0	
 00000723		     1		.code
 00000723  52		     1		push	edx
 00000724  BA 00000279 R     1		mov	edx,OFFSET ??0007
 00000729  E8 00000000 E     1		call	WriteString
 0000072E  5A		     1		pop	edx

 0000072F			    ColumnLabel:
 0000072F  E8 00000000 E	        call WriteChar      ; Print column label
				        mWrite <"   ">
 0000027E		     1		.data		
 0000027E 20 20 20 00	     1		??0008 BYTE "   ",0	
 00000734		     1		.code
 00000734  52		     1		push	edx
 00000735  BA 0000027E R     1		mov	edx,OFFSET ??0008
 0000073A  E8 00000000 E     1		call	WriteString
 0000073F  5A		     1		pop	edx
 00000740  02 C2		        add al, dl          ; increment column label
 00000742  FE C9		        dec cl              ; decrement column counter
 00000744  75 E9		        jnz ColumnLabel     ; if c != 0, continue printing labels

 00000746  E8 00000000 E	    call crlf
 0000074B  E8 00000000 E	    call crlf

 00000750  C3			    ret
 00000751			PrintChessboard ENDP

				; Gets character from esi and prints it
 00000751			PrintPiece PROC uses edx    ; edx is used in PrintChessboard for nonvolitile temp information

 00000751  52		   *	    push   edx
 00000752  8A 06		    mov al, BYTE PTR [esi]  ; Get piece
 00000754  24 0F		    and al, 0Fh             ; Isolate type

				    ; Check which piece type is on the square
 00000756  3C 06		    cmp al, PAWN
 00000758  74 16		    je PrintPawn            ; If Pawn

 0000075A  3C 05		    cmp al, ROOK
 0000075C  74 16		    je PrintRook            ; If Rook

 0000075E  3C 03		    cmp al, KNIGHT
 00000760  74 16		    je PrintKnight          ; If Knight

 00000762  3C 04		    cmp al, BISHOP
 00000764  74 16		    je PrintBishop          ; If Bishop

 00000766  3C 02		    cmp al, QUEEN
 00000768  74 16		    je PrintQueen           ; If Queen

 0000076A  3C 01		    cmp al, KING
 0000076C  74 16		    je PrintKing            ; If King

 0000076E  EB 18		    jmp PrintBlank          ; Else

				    ; Save character to DL
 00000770			    PrintPawn:
 00000770  B2 70		        mov dl, SYM_PAWN
 00000772  EB 18		        jmp CheckColor
 00000774			    PrintRook:
 00000774  B2 52		        mov dl, SYM_ROOK
 00000776  EB 14		        jmp CheckColor
 00000778			    PrintKnight:
 00000778  B2 4E		        mov dl, SYM_KNIGHT
 0000077A  EB 10		        jmp CheckColor
 0000077C			    PrintBishop:
 0000077C  B2 42		        mov dl, SYM_BISHOP
 0000077E  EB 0C		        jmp CheckColor
 00000780			    PrintQueen:
 00000780  B2 51		        mov dl, SYM_QUEEN
 00000782  EB 08		        jmp CheckColor
 00000784			    PrintKing:
 00000784  B2 4B		        mov dl, SYM_KING
 00000786  EB 04		        jmp CheckColor
 00000788			    PrintBlank:
 00000788  B2 2D		        mov dl, SYM_BLANK
 0000078A  EB 18		        jmp ColorDefault    ; Skip the color check
				        
				    ; Check the color of square
 0000078C			    CheckColor:
 0000078C  8A 06		        mov al, BYTE PTR [esi]      ; Get piece
 0000078E  24 80		        and al, IS_BLACK            ; Isolate color
 00000790  3C 80		        cmp al, IS_BLACK
 00000792  74 09		        je ColorChangeToBlack
 00000794  75 00		        jne ColorChangeToWhite

				    ; Set Color
 00000796			    ColorChangeToWhite:
 00000796  B8 0000000E		    mov eax, yellow + (black*16)    ; White is represented with yellow
 0000079B  EB 0C		    jmp SetPrintColor
 0000079D			    ColorChangeToBlack:
 0000079D  B8 00000004		    mov eax, red + (black*16)       ; Black is represented with red
 000007A2  EB 05		    jmp SetPrintColor
 000007A4			    ColorDefault:
 000007A4  B8 0000000F		    mov eax, white + (black*16)     ; Blank squares are represented with white

 000007A9			    SetPrintColor:
 000007A9  E8 00000000 E	    call SetTextColor

				    ; Set stored character to al
 000007AE  8A C2		    mov al, dl
 000007B0  E8 00000000 E	    call WriteChar
				    mWrite <"   ">
 00000282		     1		.data		
 00000282 20 20 20 00	     1		??0009 BYTE "   ",0	
 000007B5		     1		.code
 000007B5  52		     1		push	edx
 000007B6  BA 00000282 R     1		mov	edx,OFFSET ??0009
 000007BB  E8 00000000 E     1		call	WriteString
 000007C0  5A		     1		pop	edx

				    ret
 000007C1  5A		   *	    pop    edx
 000007C2  C3		   *	    ret    00000h
 000007C3			PrintPiece ENDP



				END main
Microsoft (R) Macro Assembler Version 14.44.35217.0	    10/18/25 13:24:52
TerminalChess.asm					     Symbols 2 - 1




Macros:

                N a m e                 Type

GetFeedback  . . . . . . . . . .	Proc
IsDefined  . . . . . . . . . . .	Func
PrintFeedback  . . . . . . . . .	Proc
SetFeedback  . . . . . . . . . .	Proc
Startup  . . . . . . . . . . . .	Proc
mDumpMem . . . . . . . . . . . .	Proc
mDump  . . . . . . . . . . . . .	Proc
mGotoxy  . . . . . . . . . . . .	Proc
mReadString  . . . . . . . . . .	Proc
mShowRegister  . . . . . . . . .	Proc
mShow  . . . . . . . . . . . . .	Proc
mWriteLn . . . . . . . . . . . .	Proc
mWriteSpace  . . . . . . . . . .	Proc
mWriteString . . . . . . . . . .	Proc
mWrite . . . . . . . . . . . . .	Proc


Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CONSOLE_CURSOR_INFO  . . . . . .	 00000008
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  bVisible . . . . . . . . . . .	 00000004	 DWord
CONSOLE_SCREEN_BUFFER_INFO . . .	 00000016
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCursorPosition . . . . . . .	 00000004	 DWord
  wAttributes  . . . . . . . . .	 00000008	 Word
  srWindow . . . . . . . . . . .	 0000000A	 QWord
  dwMaximumWindowSize  . . . . .	 00000012	 DWord
COORD  . . . . . . . . . . . . .	 00000004
  X  . . . . . . . . . . . . . .	 00000000	 Word
  Y  . . . . . . . . . . . . . .	 00000002	 Word
FILETIME . . . . . . . . . . . .	 00000008
  loDateTime . . . . . . . . . .	 00000000	 DWord
  hiDateTime . . . . . . . . . .	 00000004	 DWord
FOCUS_EVENT_RECORD . . . . . . .	 00000004
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
FPU_ENVIRON  . . . . . . . . . .	 0000001C
  controlWord  . . . . . . . . .	 00000000	 Word
  statusWord . . . . . . . . . .	 00000004	 Word
  tagWord  . . . . . . . . . . .	 00000008	 Word
  instrPointerOffset . . . . . .	 0000000C	 DWord
  instrPointerSelector . . . . .	 00000010	 DWord
  operandPointerOffset . . . . .	 00000014	 DWord
  operandPointerSelector . . . .	 00000018	 Word
INPUT_RECORD . . . . . . . . . .	 00000014
  EventType  . . . . . . . . . .	 00000000	 Word
  Event  . . . . . . . . . . . .	 00000004	 XmmWord
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
  dwSize . . . . . . . . . . . .	 00000000	 DWord
  dwCommandId  . . . . . . . . .	 00000000	 DWord
  bSetFocus  . . . . . . . . . .	 00000000	 DWord
KEY_EVENT_RECORD . . . . . . . .	 00000010
  bKeyDown . . . . . . . . . . .	 00000000	 DWord
  wRepeatCount . . . . . . . . .	 00000004	 Word
  wVirtualKeyCode  . . . . . . .	 00000006	 Word
  wVirtualScanCode . . . . . . .	 00000008	 Word
  uChar  . . . . . . . . . . . .	 0000000A	 Word
  UnicodeChar  . . . . . . . . .	 00000000	 Word
  AsciiChar  . . . . . . . . . .	 00000000	 Byte
  dwControlKeyState  . . . . . .	 0000000C	 DWord
MENU_EVENT_RECORD  . . . . . . .	 00000004
  dwCommandId  . . . . . . . . .	 00000000	 DWord
MOUSE_EVENT_RECORD . . . . . . .	 00000010
  dwMousePosition  . . . . . . .	 00000000	 DWord
  dwButtonState  . . . . . . . .	 00000004	 DWord
  dwMouseControlKeyState . . . .	 00000008	 DWord
  dwEventFlags . . . . . . . . .	 0000000C	 DWord
SMALL_RECT . . . . . . . . . . .	 00000008
  Left . . . . . . . . . . . . .	 00000000	 Word
  Top  . . . . . . . . . . . . .	 00000002	 Word
  Right  . . . . . . . . . . . .	 00000004	 Word
  Bottom . . . . . . . . . . . .	 00000006	 Word
SYSTEMTIME . . . . . . . . . . .	 00000010
  wYear  . . . . . . . . . . . .	 00000000	 Word
  wMonth . . . . . . . . . . . .	 00000002	 Word
  wDayOfWeek . . . . . . . . . .	 00000004	 Word
  wDay . . . . . . . . . . . . .	 00000006	 Word
  wHour  . . . . . . . . . . . .	 00000008	 Word
  wMinute  . . . . . . . . . . .	 0000000A	 Word
  wSecond  . . . . . . . . . . .	 0000000C	 Word
  wMilliseconds  . . . . . . . .	 0000000E	 Word
WINDOW_BUFFER_SIZE_RECORD  . . .	 00000004
  dwSize . . . . . . . . . . . .	 00000000	 DWord


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00001000 Para	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000286 Para	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000007C3 Para	  Public  'CODE'	


Procedures, parameters, and locals:

                N a m e                 Type     Value    Attr

CheckPath  . . . . . . . . . . .	P Near	 0000038E _TEXT	Length= 00000058 Public STDCALL
  MOVE_IS_INVALID  . . . . . . .	L Near	 0000039A _TEXT	
  LOOP_START . . . . . . . . . .	L Near	 000003A3 _TEXT	
  AFTER_LOOP . . . . . . . . . .	L Near	 000003C1 _TEXT	
  KING_CHECK . . . . . . . . . .	L Near	 000003D5 _TEXT	
  SKIP . . . . . . . . . . . . .	L Near	 000003E4 _TEXT	
CloseFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CloseHandle  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Clrscr . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateFileA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
CreateOutputFile . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Crlf . . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Delay  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpMem  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
DumpRegs . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToDosDateTime  . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FileTimeToSystemTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FlushConsoleInputBuffer  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
FormatMessageA . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetChessInput  . . . . . . . . .	P Near	 00000512 _TEXT	Length= 0000001B Public STDCALL
GetCommandLineA  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCommandTail . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCP . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetConsoleScreenBufferInfo . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetCoordsDifference  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetDateTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetFileTime  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetKeyState  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLastError . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMaxXY . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetMseconds  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetNumberOfConsoleInputEvents  .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetProcessHeap . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetStdHandle . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetSystemTime  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
GetTickCount . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Gotoxy . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapAlloc  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapCreate . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapDestroy  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapFree . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
HeapSize . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
InitChessboard . . . . . . . . .	P Near	 00000593 _TEXT	Length= 00000096 Public STDCALL
  PlaceBlackPawns  . . . . . . .	L Near	 000005D2 _TEXT	
  PlaceWhitePawns  . . . . . . .	L Near	 00000620 _TEXT	
InputToMove  . . . . . . . . . .	P Near	 00000168 _TEXT	Length= 00000226 Public STDCALL
  SKIP_PUSH_EDI  . . . . . . . .	L Near	 00000170 _TEXT	
  PAWN_LOGIC . . . . . . . . . .	L Near	 000001B3 _TEXT	
  QUEEN_LOGIC  . . . . . . . . .	L Near	 000001C7 _TEXT	
  KNIGHT_LOGIC . . . . . . . . .	L Near	 000001DB _TEXT	
  BISHOP_LOGIC . . . . . . . . .	L Near	 000001EF _TEXT	
  ROOK_LOGIC . . . . . . . . . .	L Near	 00000203 _TEXT	
  KING_LOGIC . . . . . . . . . .	L Near	 00000217 _TEXT	
  AFTER_COPY_LOGIC . . . . . . .	L Near	 00000229 _TEXT	
  SOURCE_CORRECT_COLOR . . . . .	L Near	 00000246 _TEXT	
  CHECK_COLOR  . . . . . . . . .	L Near	 0000025B _TEXT	
  DONT_CHECK_COLOR . . . . . . .	L Near	 0000026F _TEXT	
  DIAGONAL_RET . . . . . . . . .	L Near	 00000279 _TEXT	
  PARALLEL_RET . . . . . . . . .	L Near	 0000027E _TEXT	
  LSHAPE_RET . . . . . . . . . .	L Near	 00000283 _TEXT	
  FORWARD_ONLY_RET . . . . . . .	L Near	 00000288 _TEXT	
  DIAGONAL_LOGIC . . . . . . . .	L Near	 00000294 _TEXT	
  PARALLEL_LOGIC . . . . . . . .	L Near	 000002A7 _TEXT	
  FLIP . . . . . . . . . . . . .	L Near	 000002AF _TEXT	
  IS_PARALLEL  . . . . . . . . .	L Near	 000002C1 _TEXT	
  LSHAPE_LOGIC . . . . . . . . .	L Near	 000002D0 _TEXT	
  FLIP2  . . . . . . . . . . . .	L Near	 000002D9 _TEXT	
  IS_LSHAPE  . . . . . . . . . .	L Near	 000002EA _TEXT	
  FORWARD_ONLY_LOGIC . . . . . .	L Near	 000002F4 _TEXT	
  CHECK_DOUBLE . . . . . . . . .	L Near	 00000339 _TEXT	
  CHECK_DIRECTION  . . . . . . .	L Near	 0000034F _TEXT	
  F_ONLY_CONTINUE  . . . . . . .	L Near	 00000379 _TEXT	
  SKIP . . . . . . . . . . . . .	L Near	 00000385 _TEXT	
  SKIP_POP_EDI . . . . . . . . .	L Near	 0000038B _TEXT	
IsDigit  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
LocalFree  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MessageBoxA  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MoveDPointerToSquare . . . . . .	P Near	 00000640 _TEXT	Length= 00000017 Public STDCALL
MoveSPointerToSquare . . . . . .	P Near	 00000629 _TEXT	Length= 00000017 Public STDCALL
MsgBoxAsk  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
MsgBox . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
NormalizeVectors . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
OpenInputFile  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseDecimal32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ParseInteger32 . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PeekConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
PrintChessboard  . . . . . . . .	P Near	 000006AC _TEXT	Length= 000000A5 Public STDCALL
  PrintWhiteTurn . . . . . . . .	L Near	 000006C0 _TEXT	
  PrintBlackTurn . . . . . . . .	L Near	 000006CB _TEXT	
  RowStart . . . . . . . . . . .	L Near	 000006D4 _TEXT	
  PieceStart . . . . . . . . . .	L Near	 000006F2 _TEXT	
  ColumnLabel  . . . . . . . . .	L Near	 0000072F _TEXT	
PrintPiece . . . . . . . . . . .	P Near	 00000751 _TEXT	Length= 00000072 Public STDCALL
  PrintPawn  . . . . . . . . . .	L Near	 00000770 _TEXT	
  PrintRook  . . . . . . . . . .	L Near	 00000774 _TEXT	
  PrintKnight  . . . . . . . . .	L Near	 00000778 _TEXT	
  PrintBishop  . . . . . . . . .	L Near	 0000077C _TEXT	
  PrintQueen . . . . . . . . . .	L Near	 00000780 _TEXT	
  PrintKing  . . . . . . . . . .	L Near	 00000784 _TEXT	
  PrintBlank . . . . . . . . . .	L Near	 00000788 _TEXT	
  CheckColor . . . . . . . . . .	L Near	 0000078C _TEXT	
  ColorChangeToWhite . . . . . .	L Near	 00000796 _TEXT	
  ColorChangeToBlack . . . . . .	L Near	 0000079D _TEXT	
  ColorDefault . . . . . . . . .	L Near	 000007A4 _TEXT	
  SetPrintColor  . . . . . . . .	L Near	 000007A9 _TEXT	
PrintWhoseTurn . . . . . . . . .	P Near	 00000657 _TEXT	Length= 00000055 Public STDCALL
  BLACK_TURN . . . . . . . . . .	L Near	 00000673 _TEXT	
  SKIP . . . . . . . . . . . . .	L Near	 00000684 _TEXT	
ProcessInput . . . . . . . . . .	P Near	 0000052D _TEXT	Length= 00000066 Public STDCALL
  RANGE_ERROR  . . . . . . . . .	L Near	 0000058B _TEXT	
  SKIP . . . . . . . . . . . . .	L Near	 00000592 _TEXT	
Random32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
RandomRange  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Randomize  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadChar . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleA . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadConsoleInputA  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadDec  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFile . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFloat  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadFromFile . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadHex  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadInt  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKeyFlush . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadKey  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ReadString . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleCursorPosition . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleMode . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleScreenBufferSize . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTextAttribute  . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleTitleA . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetConsoleWindowInfo . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetFilePointer . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetLocalTime . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SetTextColor . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ShowFPUStack . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Sleep  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
StrLength  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_compare  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_copy . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_length . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_trim . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
Str_ucase  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
SystemTimeToFileTime . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
VerifyMove . . . . . . . . . . .	P Near	 000003E6 _TEXT	Length= 0000012C Public STDCALL
  LOOP_START . . . . . . . . . .	L Near	 000003F4 _TEXT	
  SET_EN_PASSANT . . . . . . . .	L Near	 00000418 _TEXT	
  CHECK_MOVE_TYPE  . . . . . . .	L Near	 0000041E _TEXT	
  NORMAL_MOVE  . . . . . . . . .	L Near	 00000437 _TEXT	
  START_KING_SEARCH  . . . . . .	L Near	 00000440 _TEXT	
  KING_SEARCH  . . . . . . . . .	L Near	 00000447 _TEXT	
  IS_KING  . . . . . . . . . . .	L Near	 00000451 _TEXT	
  SKIP_KING  . . . . . . . . . .	L Near	 00000464 _TEXT	
  END_KING_SEARCH  . . . . . . .	L Near	 00000469 _TEXT	
  CHECK_FOR_ATTACKER . . . . . .	L Near	 000004B2 _TEXT	
  SKIP_PIECE . . . . . . . . . .	L Near	 000004CC _TEXT	
  IS_ATTACKER  . . . . . . . . .	L Near	 000004DF _TEXT	
  UNDO_START . . . . . . . . . .	L Near	 000004F2 _TEXT	
  END_ATTACKER_SEARCH  . . . . .	L Near	 000004FE _TEXT	
  SKIP . . . . . . . . . . . . .	L Near	 00000505 _TEXT	
WaitMsg  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBinB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteBin . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteChar  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleA  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputAttribute  . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteConsoleOutputCharacterA . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteDec . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFile  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteFloat . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHexB  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteHex . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteInt . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrameName  . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteStackFrame  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteString  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteToFile  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
WriteWindowsMsg  . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
YesOrNo  . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
chess  . . . . . . . . . . . . .	P Near	 00000052 _TEXT	Length= 00000116 Public STDCALL
  StartTurn  . . . . . . . . . .	L Near	 00000057 _TEXT	
  INVALID_MOVE_F . . . . . . . .	L Near	 000000AA _TEXT	
  MISMATCH_COLOR_F . . . . . . .	L Near	 000000B1 _TEXT	
  MISMATCH_COLOR_CAPT_F  . . . .	L Near	 000000B8 _TEXT	
  MOVE_OUTSIDE_RANGE_F . . . . .	L Near	 000000BF _TEXT	
  KING_LEFT_IN_CHECK_F . . . . .	L Near	 000000C6 _TEXT	
  EMPTY_SQUARE_MOVE_F  . . . . .	L Near	 000000CD _TEXT	
  BLOCKED_PATH_F . . . . . . . .	L Near	 000000D4 _TEXT	
  ERROR_KING_CAPTURE_F . . . . .	L Near	 000000DB _TEXT	
  ERROR_PATH_F . . . . . . . . .	L Near	 000000E2 _TEXT	
  END_OF_FEEDBACK  . . . . . . .	L Near	 000000E7 _TEXT	
  SKIP_PRINT . . . . . . . . . .	L Near	 000000EC _TEXT	
  GET_INPUT  . . . . . . . . . .	L Near	 000000FD _TEXT	
main . . . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000052 Public STDCALL
  PLAY_AGAIN . . . . . . . . . .	L Near	 0000000A _TEXT	
  INVALID_MENU . . . . . . . . .	L Near	 0000000F _TEXT	
  QUIT_GAME  . . . . . . . . . .	L Near	 0000004B _TEXT	
printf . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
scanf  . . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
wsprintfA  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

??0000 . . . . . . . . . . . . .	Byte	 000001FE _DATA	
??0001 . . . . . . . . . . . . .	Byte	 00000222 _DATA	
??0002 . . . . . . . . . . . . .	Byte	 0000023C _DATA	
??0003 . . . . . . . . . . . . .	Byte	 00000249 _DATA	
??0004 . . . . . . . . . . . . .	Byte	 00000256 _DATA	
??0005 . . . . . . . . . . . . .	Byte	 00000263 _DATA	
??0006 . . . . . . . . . . . . .	Byte	 00000275 _DATA	
??0007 . . . . . . . . . . . . .	Byte	 00000279 _DATA	
??0008 . . . . . . . . . . . . .	Byte	 0000027E _DATA	
??0009 . . . . . . . . . . . . .	Byte	 00000282 _DATA	
@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000003h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
ALT_MASK . . . . . . . . . . . .	Number	 00000003h   
BISHOP_MOVE  . . . . . . . . . .	Byte	 00000179 _DATA	
BISHOP . . . . . . . . . . . . .	Number	 00000004h   
BLACK_BISHOP . . . . . . . . . .	Number	 00000084h   
BLACK_KING . . . . . . . . . . .	Number	 00000081h   
BLACK_KNIGHT . . . . . . . . . .	Number	 00000083h   
BLACK_PAWN . . . . . . . . . . .	Number	 00000086h   
BLACK_QUEEN  . . . . . . . . . .	Number	 00000082h   
BLACK_ROOK . . . . . . . . . . .	Number	 00000085h   
BLACK_WON  . . . . . . . . . . .	Number	 00000001h   
BLOCKED_PATH_STR . . . . . . . .	Byte	 000000BA _DATA	
BLOCKED_PATH . . . . . . . . . .	Number	 00000007h   
CAPSLOCK_ON  . . . . . . . . . .	Number	 00000080h   
CHESSBOARD_COPY  . . . . . . . .	Byte	 000001BE _DATA	
CHESSBOARD . . . . . . . . . . .	Byte	 0000017E _DATA	
CREATE_ALWAYS  . . . . . . . . .	Number	 00000002h   
CREATE_NEW . . . . . . . . . . .	Number	 00000001h   
CTRL_MASK  . . . . . . . . . . .	Number	 0000000Ch   
CreateFile . . . . . . . . . . .	Text   	 CreateFileA
DIAGONAL . . . . . . . . . . . .	Number	 00000001h   
DO_NOT_SHARE . . . . . . . . . .	Number	 00000000h   
EMPTY_SQUARE_MOVE_STR  . . . . .	Byte	 00000051 _DATA	
EMPTY_SQUARE_MOVE  . . . . . . .	Number	 00000004h   
ENABLE_ECHO_INPUT  . . . . . . .	Number	 00000004h   
ENABLE_LINE_INPUT  . . . . . . .	Number	 00000002h   
ENABLE_MOUSE_INPUT . . . . . . .	Number	 00000010h   
ENABLE_PROCESSED_INPUT . . . . .	Number	 00000001h   
ENABLE_PROCESSED_OUTPUT  . . . .	Number	 00000001h   
ENABLE_WINDOW_INPUT  . . . . . .	Number	 00000008h   
ENABLE_WRAP_AT_EOL_OUTPUT  . . .	Number	 00000002h   
ENHANCED_KEY . . . . . . . . . .	Number	 00000100h   
ERROR_KING_CAPTURE_STR . . . . .	Byte	 00000125 _DATA	
ERROR_KING_CAPTURE . . . . . . .	Number	 00000009h   
ERROR_PATH_STR . . . . . . . . .	Byte	 000000EE _DATA	
ERROR_PATH . . . . . . . . . . .	Number	 00000008h   
FALSE  . . . . . . . . . . . . .	Number	 00000000h   
FEEDBACK . . . . . . . . . . . .	Byte	 00000000 _DATA	
FIFTY_MOVE_RULE  . . . . . . . .	Byte	 0000017D _DATA	
FILE_APPEND_DATA . . . . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_ARCHIVE . . . . .	Number	 00000020h   
FILE_ATTRIBUTE_COMPRESSED  . . .	Number	 00000800h   
FILE_ATTRIBUTE_DEVICE  . . . . .	Number	 00000040h   
FILE_ATTRIBUTE_DIRECTORY . . . .	Number	 00000010h   
FILE_ATTRIBUTE_ENCRYPTED . . . .	Number	 00004000h   
FILE_ATTRIBUTE_HIDDEN  . . . . .	Number	 00000002h   
FILE_ATTRIBUTE_NORMAL  . . . . .	Number	 00000080h   
FILE_ATTRIBUTE_NOT_CONTENT_INDEXED .	Number	 00002000h   
FILE_ATTRIBUTE_OFFLINE . . . . .	Number	 00001000h   
FILE_ATTRIBUTE_READONLY  . . . .	Number	 00000001h   
FILE_ATTRIBUTE_REPARSE_POINT . .	Number	 00000400h   
FILE_ATTRIBUTE_SPARSE_FILE . . .	Number	 00000200h   
FILE_ATTRIBUTE_SYSTEM  . . . . .	Number	 00000004h   
FILE_ATTRIBUTE_TEMPORARY . . . .	Number	 00000100h   
FILE_BEGIN . . . . . . . . . . .	Number	 00000000h   
FILE_CURRENT . . . . . . . . . .	Number	 00000001h   
FILE_DELETE_CHILD  . . . . . . .	Number	 00000040h   
FILE_END . . . . . . . . . . . .	Number	 00000002h   
FILE_READ_DATA . . . . . . . . .	Number	 00000001h   
FILE_SHARE_DELETE  . . . . . . .	Number	 00000004h   
FILE_SHARE_READ  . . . . . . . .	Number	 00000001h   
FILE_SHARE_WRITE . . . . . . . .	Number	 00000002h   
FILE_WRITE_DATA  . . . . . . . .	Number	 00000002h   
FOCUS_EVENT  . . . . . . . . . .	Number	 00000010h   
FORMAT_MESSAGE_ALLOCATE_BUFFER .	Number	 00000100h   
FORMAT_MESSAGE_FROM_SYSTEM . . .	Number	 00001000h   
FORWARD_ONLY . . . . . . . . . .	Number	 00000008h   
FormatMessage  . . . . . . . . .	Text   	 FormatMessageA
GAMEOVER . . . . . . . . . . . .	Number	 00000002h   
GAME_STATUS  . . . . . . . . . .	Byte	 0000017C _DATA	
GENERIC_ALL  . . . . . . . . . .	Number	 10000000h   
GENERIC_EXECUTE  . . . . . . . .	Number	 20000000h   
GENERIC_READ . . . . . . . . . .	Number	 -80000000h   
GENERIC_WRITE  . . . . . . . . .	Number	 40000000h   
GetCommandLine . . . . . . . . .	Text   	 GetCommandLineA
HANDLE . . . . . . . . . . . . .	Text   	 DWORD
HAS_MOVED  . . . . . . . . . . .	Number	 00000020h   
HEAP_GENERATE_EXCEPTIONS . . . .	Number	 00000004h   
HEAP_GROWABLE  . . . . . . . . .	Number	 00000002h   
HEAP_NO_SERIALIZE  . . . . . . .	Number	 00000001h   
HEAP_REALLOC_IN_PLACE_ONLY . . .	Number	 00000010h   
HEAP_ZERO_MEMORY . . . . . . . .	Number	 00000008h   
IDABORT  . . . . . . . . . . . .	Number	 00000003h   
IDCANCEL . . . . . . . . . . . .	Number	 00000002h   
IDCLOSE  . . . . . . . . . . . .	Number	 00000008h   
IDCONTINUE . . . . . . . . . . .	Number	 0000000Bh   
IDHELP . . . . . . . . . . . . .	Number	 00000009h   
IDIGNORE . . . . . . . . . . . .	Number	 00000005h   
IDNO . . . . . . . . . . . . . .	Number	 00000007h   
IDOK . . . . . . . . . . . . . .	Number	 00000001h   
IDRETRY  . . . . . . . . . . . .	Number	 00000004h   
IDTIMEOUT  . . . . . . . . . . .	Number	 00007D00h   
IDTRYAGAIN . . . . . . . . . . .	Number	 0000000Ah   
IDYES  . . . . . . . . . . . . .	Number	 00000006h   
INPUT_SIZE . . . . . . . . . . .	Number	 00000005h   
INVALID_HANDLE_VALUE . . . . . .	Number	 -00000001h   
INVALID_MOVE_STR . . . . . . . .	Byte	 00000001 _DATA	
INVALID_MOVE . . . . . . . . . .	Number	 00000001h   
IS_BLACK_TURN  . . . . . . . . .	Number	 00000080h   
IS_BLACK . . . . . . . . . . . .	Number	 00000080h   
IS_EN_PASSANTABLE  . . . . . . .	Number	 00000010h   
IS_IN_CHECK  . . . . . . . . . .	Number	 00000008h   
KBDOWN_FLAG  . . . . . . . . . .	Number	 00000001h   
KEY_EVENT  . . . . . . . . . . .	Number	 00000001h   
KEY_MASKS  . . . . . . . . . . .	Number	 0000001Fh   
KING_LEFT_IN_CHECK_STR . . . . .	Byte	 00000033 _DATA	
KING_LEFT_IN_CHECK . . . . . . .	Number	 00000003h   
KING_MOVE  . . . . . . . . . . .	Byte	 00000176 _DATA	
KING . . . . . . . . . . . . . .	Number	 00000001h   
KNIGHT_MOVE  . . . . . . . . . .	Byte	 00000178 _DATA	
KNIGHT . . . . . . . . . . . . .	Number	 00000003h   
LEFT_ALT_PRESSED . . . . . . . .	Number	 00000002h   
LEFT_CTRL_PRESSED  . . . . . . .	Number	 00000008h   
LSHAPE . . . . . . . . . . . . .	Number	 00000004h   
MB_ABORTRETRYIGNORE  . . . . . .	Number	 00000002h   
MB_APPLMODAL . . . . . . . . . .	Number	 00000000h   
MB_CANCELTRYCONTINUE . . . . . .	Number	 00000006h   
MB_DEFBUTTON1  . . . . . . . . .	Number	 00000000h   
MB_DEFBUTTON2  . . . . . . . . .	Number	 00000100h   
MB_DEFBUTTON3  . . . . . . . . .	Number	 00000200h   
MB_DEFBUTTON4  . . . . . . . . .	Number	 00000300h   
MB_HELP  . . . . . . . . . . . .	Number	 00004000h   
MB_ICONASTERISK  . . . . . . . .	Number	 00000040h   
MB_ICONERROR . . . . . . . . . .	Number	 00000010h   
MB_ICONEXCLAMATION . . . . . . .	Number	 00000030h   
MB_ICONHAND  . . . . . . . . . .	Number	 00000010h   
MB_ICONINFORMATION . . . . . . .	Number	 00000040h   
MB_ICONQUESTION  . . . . . . . .	Number	 00000020h   
MB_ICONSTOP  . . . . . . . . . .	Number	 00000010h   
MB_ICONWARNING . . . . . . . . .	Number	 00000030h   
MB_OKCANCEL  . . . . . . . . . .	Number	 00000001h   
MB_OK  . . . . . . . . . . . . .	Number	 00000000h   
MB_RETRYCANCEL . . . . . . . . .	Number	 00000005h   
MB_SYSTEMMODAL . . . . . . . . .	Number	 00001000h   
MB_TASKMODAL . . . . . . . . . .	Number	 00002000h   
MB_USERICON  . . . . . . . . . .	Number	 00000080h   
MB_YESNOCANCEL . . . . . . . . .	Number	 00000003h   
MB_YESNO . . . . . . . . . . . .	Number	 00000004h   
MENU_EVENT . . . . . . . . . . .	Number	 00000008h   
MISMATCH_COLOR_CAPT_STR  . . . .	Byte	 00000092 _DATA	
MISMATCH_COLOR_CAPT  . . . . . .	Number	 00000006h   
MISMATCH_COLOR_STR . . . . . . .	Byte	 0000006D _DATA	
MISMATCH_COLOR . . . . . . . . .	Number	 00000005h   
MOUSE_EVENT  . . . . . . . . . .	Number	 00000002h   
MOVE_OUTSIDE_RANGE_STR . . . . .	Byte	 00000011 _DATA	
MOVE_OUTSIDE_RANGE . . . . . . .	Number	 00000002h   
MessageBox . . . . . . . . . . .	Text   	 MessageBoxA
NO_EN_PASSANT  . . . . . . . . .	Number	 000000EFh   
NULL . . . . . . . . . . . . . .	Number	 00000000h   
NUMLOCK_ON . . . . . . . . . . .	Number	 00000020h   
OPEN_ALWAYS  . . . . . . . . . .	Number	 00000004h   
OPEN_EXISTING  . . . . . . . . .	Number	 00000003h   
PARALLEL . . . . . . . . . . . .	Number	 00000002h   
PAWN_MOVE  . . . . . . . . . . .	Byte	 0000017B _DATA	
PAWN . . . . . . . . . . . . . .	Number	 00000006h   
PeekConsoleInput . . . . . . . .	Text   	 PeekConsoleInputA
QUEEN_MOVE . . . . . . . . . . .	Byte	 00000177 _DATA	
QUEEN  . . . . . . . . . . . . .	Number	 00000002h   
RIGHT_ALT_PRESSED  . . . . . . .	Number	 00000001h   
RIGHT_CTRL_PRESSED . . . . . . .	Number	 00000004h   
ROOK_MOVE  . . . . . . . . . . .	Byte	 0000017A _DATA	
ROOK . . . . . . . . . . . . . .	Number	 00000005h   
ReadConsoleInput . . . . . . . .	Text   	 ReadConsoleInputA
ReadConsole  . . . . . . . . . .	Text   	 ReadConsoleA
SCROLLLOCK_ON  . . . . . . . . .	Number	 00000040h   
SHIFT_MASK . . . . . . . . . . .	Number	 00000010h   
SHIFT_PRESSED  . . . . . . . . .	Number	 00000010h   
STD_ERROR_HANDLE . . . . . . . .	Number	 -0000000Ch   
STD_INPUT_HANDLE . . . . . . . .	Number	 -0000000Ah   
STD_OUTPUT_HANDLE  . . . . . . .	Number	 -0000000Bh   
SYM_BISHOP . . . . . . . . . . .	Number	 00000042h   
SYM_BLANK  . . . . . . . . . . .	Number	 0000002Dh   
SYM_KING . . . . . . . . . . . .	Number	 0000004Bh   
SYM_KNIGHT . . . . . . . . . . .	Number	 0000004Eh   
SYM_PAWN . . . . . . . . . . . .	Number	 00000070h   
SYM_QUEEN  . . . . . . . . . . .	Number	 00000051h   
SYM_ROOK . . . . . . . . . . . .	Number	 00000052h   
SetConsoleTitle  . . . . . . . .	Text   	 SetConsoleTitleA
TAB  . . . . . . . . . . . . . .	Number	 00000009h   
TRUE . . . . . . . . . . . . . .	Number	 00000001h   
TRUNCATE_EXISTING  . . . . . . .	Number	 00000005h   
VK_11  . . . . . . . . . . . . .	Number	 000000BDh   
VK_12  . . . . . . . . . . . . .	Number	 000000BBh   
VK_ADD . . . . . . . . . . . . .	Number	 0000006Bh   
VK_BACK  . . . . . . . . . . . .	Number	 00000008h   
VK_CANCEL  . . . . . . . . . . .	Number	 00000003h   
VK_CAPITAL . . . . . . . . . . .	Number	 00000014h   
VK_CLEAR . . . . . . . . . . . .	Number	 0000000Ch   
VK_CONTROL . . . . . . . . . . .	Number	 00000011h   
VK_DECIMAL . . . . . . . . . . .	Number	 0000006Eh   
VK_DELETE  . . . . . . . . . . .	Number	 0000002Eh   
VK_DIVIDE  . . . . . . . . . . .	Number	 0000006Fh   
VK_DOWN  . . . . . . . . . . . .	Number	 00000028h   
VK_END . . . . . . . . . . . . .	Number	 00000023h   
VK_ESCAPE  . . . . . . . . . . .	Number	 0000001Bh   
VK_EXECUTE . . . . . . . . . . .	Number	 0000002Bh   
VK_F10 . . . . . . . . . . . . .	Number	 00000079h   
VK_F11 . . . . . . . . . . . . .	Number	 0000007Ah   
VK_F12 . . . . . . . . . . . . .	Number	 0000007Bh   
VK_F13 . . . . . . . . . . . . .	Number	 0000007Ch   
VK_F14 . . . . . . . . . . . . .	Number	 0000007Dh   
VK_F15 . . . . . . . . . . . . .	Number	 0000007Eh   
VK_F16 . . . . . . . . . . . . .	Number	 0000007Fh   
VK_F17 . . . . . . . . . . . . .	Number	 00000080h   
VK_F18 . . . . . . . . . . . . .	Number	 00000081h   
VK_F19 . . . . . . . . . . . . .	Number	 00000082h   
VK_F1  . . . . . . . . . . . . .	Number	 00000070h   
VK_F20 . . . . . . . . . . . . .	Number	 00000083h   
VK_F21 . . . . . . . . . . . . .	Number	 00000084h   
VK_F22 . . . . . . . . . . . . .	Number	 00000085h   
VK_F23 . . . . . . . . . . . . .	Number	 00000086h   
VK_F24 . . . . . . . . . . . . .	Number	 00000087h   
VK_F2  . . . . . . . . . . . . .	Number	 00000071h   
VK_F3  . . . . . . . . . . . . .	Number	 00000072h   
VK_F4  . . . . . . . . . . . . .	Number	 00000073h   
VK_F5  . . . . . . . . . . . . .	Number	 00000074h   
VK_F6  . . . . . . . . . . . . .	Number	 00000075h   
VK_F7  . . . . . . . . . . . . .	Number	 00000076h   
VK_F8  . . . . . . . . . . . . .	Number	 00000077h   
VK_F9  . . . . . . . . . . . . .	Number	 00000078h   
VK_HELP  . . . . . . . . . . . .	Number	 0000002Fh   
VK_HOME  . . . . . . . . . . . .	Number	 00000024h   
VK_INSERT  . . . . . . . . . . .	Number	 0000002Dh   
VK_LBUTTON . . . . . . . . . . .	Number	 00000001h   
VK_LCONTROL  . . . . . . . . . .	Number	 000000A2h   
VK_LEFT  . . . . . . . . . . . .	Number	 00000025h   
VK_LMENU . . . . . . . . . . . .	Number	 000000A4h   
VK_LSHIFT  . . . . . . . . . . .	Number	 000000A0h   
VK_MENU  . . . . . . . . . . . .	Number	 00000012h   
VK_MULTIPLY  . . . . . . . . . .	Number	 0000006Ah   
VK_NEXT  . . . . . . . . . . . .	Number	 00000022h   
VK_NUMLOCK . . . . . . . . . . .	Number	 00000090h   
VK_NUMPAD0 . . . . . . . . . . .	Number	 00000060h   
VK_NUMPAD1 . . . . . . . . . . .	Number	 00000061h   
VK_NUMPAD2 . . . . . . . . . . .	Number	 00000062h   
VK_NUMPAD3 . . . . . . . . . . .	Number	 00000063h   
VK_NUMPAD4 . . . . . . . . . . .	Number	 00000064h   
VK_NUMPAD5 . . . . . . . . . . .	Number	 00000065h   
VK_NUMPAD6 . . . . . . . . . . .	Number	 00000066h   
VK_NUMPAD7 . . . . . . . . . . .	Number	 00000067h   
VK_NUMPAD8 . . . . . . . . . . .	Number	 00000068h   
VK_NUMPAD9 . . . . . . . . . . .	Number	 00000069h   
VK_PAUSE . . . . . . . . . . . .	Number	 00000013h   
VK_PRINT . . . . . . . . . . . .	Number	 0000002Ah   
VK_PRIOR . . . . . . . . . . . .	Number	 00000021h   
VK_RBUTTON . . . . . . . . . . .	Number	 00000002h   
VK_RCONTROL  . . . . . . . . . .	Number	 000000A3h   
VK_RETURN  . . . . . . . . . . .	Number	 0000000Dh   
VK_RIGHT . . . . . . . . . . . .	Number	 00000027h   
VK_RMENU . . . . . . . . . . . .	Number	 000000A5h   
VK_RSHIFT  . . . . . . . . . . .	Number	 000000A1h   
VK_SCROLL  . . . . . . . . . . .	Number	 00000091h   
VK_SEPARATER . . . . . . . . . .	Number	 0000006Ch   
VK_SHIFT . . . . . . . . . . . .	Number	 00000010h   
VK_SNAPSHOT  . . . . . . . . . .	Number	 0000002Ch   
VK_SPACE . . . . . . . . . . . .	Number	 00000020h   
VK_SUBTRACT  . . . . . . . . . .	Number	 0000006Dh   
VK_TAB . . . . . . . . . . . . .	Number	 00000009h   
VK_UP  . . . . . . . . . . . . .	Number	 00000026h   
WINDOW_BUFFER_SIZE_EVENT . . . .	Number	 00000004h   
WriteConsoleOutputCharacter  . .	Text   	 WriteConsoleOutputCharacterA
WriteConsole . . . . . . . . . .	Text   	 WriteConsoleA
black  . . . . . . . . . . . . .	Number	 00000000h   
blue . . . . . . . . . . . . . .	Number	 00000001h   
brown  . . . . . . . . . . . . .	Number	 00000006h   
chess_title  . . . . . . . . . .	Byte	 00000162 _DATA	
cyan . . . . . . . . . . . . . .	Number	 00000003h   
exit . . . . . . . . . . . . . .	Text   	 INVOKE ExitProcess,0
gray . . . . . . . . . . . . . .	Number	 00000008h   
green  . . . . . . . . . . . . .	Number	 00000002h   
lightBlue  . . . . . . . . . . .	Number	 00000009h   
lightCyan  . . . . . . . . . . .	Number	 0000000Bh   
lightGray  . . . . . . . . . . .	Number	 00000007h   
lightGreen . . . . . . . . . . .	Number	 0000000Ah   
lightMagenta . . . . . . . . . .	Number	 0000000Dh   
lightRed . . . . . . . . . . . .	Number	 0000000Ch   
magenta  . . . . . . . . . . . .	Number	 00000005h   
red  . . . . . . . . . . . . . .	Number	 00000004h   
userInput  . . . . . . . . . . .	Byte	 00000171 _DATA	
white  . . . . . . . . . . . . .	Number	 0000000Fh   
wsprintf . . . . . . . . . . . .	Text   	 wsprintfA
yellow . . . . . . . . . . . . .	Number	 0000000Eh   

	   0 Warnings
	   0 Errors
